*** 1- Introduction ***
---

## Lecture Overview: Product Review Summarizer Project

### 1. Project Introduction

* This section introduces a more advanced and engaging project.
* The goal is to build a **product review summarizer**.
* Users can generate a concise summary instead of reading all individual reviews.

### 2. User Experience Flow

* A product page displays:

  * A list of user reviews for a product.
  * A button to summarize the reviews.
* When the user clicks the **Summarize Reviews** button:

  * A summary is generated automatically.
  * The summary helps users quickly understand overall feedback.

### 3. Summary Persistence

* Once the summary is generated:

  * It is stored in the database.
  * When the user revisits the page, the summary is retrieved from the database.
  * The summary does **not** need to be regenerated each time.
* This improves:

  * Performance
  * Cost efficiency
  * User experience

### 4. Common Industry Pattern

* This “generate once, reuse later” pattern is increasingly common in modern applications.
* Especially relevant for:

  * AI-powered features
  * Content summarization
  * Recommendation systems

### 5. Project Complexity

* This project is more complex than the previous chatbot project.
* It is a **full-stack application**, involving:

  * Frontend (user interface)
  * Backend (business logic)
  * Database (data storage)

### 6. Database Introduction

* The project uses a database to store summaries.
* Prior database knowledge is **not required**.
* The instructor will cover:

  * Essential database concepts
  * Only what is necessary for this project

### 7. Learning Mindset

* The project is meant to be built step by step.
* Learners are encouraged to:

  * Take their time
  * Follow along carefully
  * Treat this as a hands-on learning experience

---


*** 2- Setting Up the Database ***
---

## Lecture Overview: Database Setup for the Project

### 1. Project Complexity

* This project is more complex than the previously built chatbot project.
* It is a **full-stack application**.
* The application includes its **own database**, which is a core component of the system.

### 2. Purpose of This Segment

* The focus of this segment is on **setting up the database from scratch**.
* The database will serve as the foundation for the rest of the application.

### 3. Database Initialization

* The database will be:

  * Created from the ground up
  * Properly structured to support application features

### 4. Populating the Database

* The database will be filled with **realistic sample data**.
* This ensures:

  * Meaningful testing
  * More realistic development scenarios
  * Better understanding of how the application behaves with real data

### 5. Role of the Database in Development

* Having realistic data allows developers to:

  * Build features more effectively
  * Test logic and edge cases
  * Develop and debug the application with confidence

### 6. Next Steps

* With the database in place and populated:

  * The rest of the application can be built on top of it
  * Backend and frontend features can be developed incrementally

---


*** 2.1- Setting Up MySQL ***
---

## Lecture Overview: Database Setup with MySQL

### 1. Purpose of This Step

* Before building the API, a database must be set up.
* The database will store:

  * Products
  * Reviews
  * Generated summaries
* This database is a foundational part of the application.

### 2. Database Technology Choice

* The project uses **MySQL**.
* MySQL is:

  * Open source
  * A relational database system
  * Widely used in real-world production applications

### 3. Installation Options

* If MySQL is already installed locally:

  * You can continue using the existing installation.
* If MySQL is not installed:

  * Download and install it from the official website.

### 4. Downloading MySQL

* Open a browser and go to **mysql.com**.
* Navigate to the **Downloads** section.
* Scroll to the bottom and select **MySQL Community Downloads**.
* Click on **MySQL Community Server**.
* Choose the latest version for your operating system.

#### Mac-Specific Notes

* Select the correct package based on CPU architecture:

  * ARM (Apple Silicon)
  * x86 (Intel CPUs)
* On the download page:

  * No login or signup is required.
  * Click **“No thanks, just start my download”**.

### 5. Installing MySQL

* Open the installer once the download completes.
* Follow the installation steps:

  * Click **Continue**
  * Agree to the license terms
  * Proceed with installation
* When prompted:

  * Enter your computer’s login password.
* Set a password for the **root (admin) MySQL user**.

  * This password is important and will be used later in the application.
  * Make sure to remember it.
* Complete the installation.
* Enter your computer password again if requested.
* After installation, the installer file can be moved to trash.

### 6. Verifying the Installation

* Open a terminal window.
* Run the following command:
-------------------code----------------------
mysql -u root -p
-------------------code----------------------

* Press Enter.
* When prompted:

  * Enter the MySQL root password you created during installation.
* If the MySQL shell opens successfully:

  * MySQL is installed correctly.

### 7. Exiting the MySQL Shell

* To exit the MySQL shell:

  * Type `quit`
  * Press Enter

### 8. Next Step

* With MySQL installed and verified:

  * The next step is to set up **Prisma**
  * Prisma will be used to interact with the database from the application

---

*** 2.2- Setting Up Prisma ***
---

## Lecture Overview: Connecting MySQL to the Application Using Prisma

### 1. Goal of This Lesson

* Now that MySQL is running, the next step is to connect the application to the database.
* This connection will be handled using **Prisma**.

---

## 2. What Is Prisma?

* Prisma is an **ORM (Object Relational Mapping) tool**.
* It sits between:

  * The application code
  * The database
* Prisma acts like a translator:

  * Converts application code into database queries
  * Provides a clean and type-safe way to interact with the database

---

## 3. Preparing the Project

* Open a terminal window.
* Navigate to the **server directory** of the project.
* Two Prisma-related packages need to be installed:

  * One for development
  * One for runtime usage

---

## 4. Installing Prisma Dependencies

### 4.1 Install Prisma CLI (Development Dependency)

* Run the following command:
-------------------code----------------------
bun add -d prisma
-------------------code----------------------
* Purpose:

  * Provides a command-line interface
  * Used to create and manage the database schema

### 4.2 Install Prisma Client (Runtime Dependency)

* Run:
-------------------code----------------------
bun add @prisma/client
-------------------code----------------------
* Purpose:

  * Allows the application code to communicate with the database

---

## 5. Initializing Prisma

* Run the following command in the server directory:

-------------------code----------------------
bunx prisma init
-------------------code----------------------
* This initializes Prisma for the project.

### Result of Initialization

* A new directory named **prisma** is created.
* Inside it, a **schema file** is generated.

---

## 6. Understanding the Prisma Schema File

* The schema file contains two main sections:

  1. **Client definition**

     * Specifies how Prisma generates the client
  2. **Database definition**

     * Specifies which database is being used and how to connect to it

---

## 7. Configuring Prisma for MySQL

### 7.1 Change Database Provider

* The default provider is set to PostgreSQL.
* Change the provider to **MySQL**.

### 7.2 Database Connection URL

* Prisma uses an environment variable named:

  * `DATABASE_URL`
* Copy this key name.

---

## 8. Updating the Environment File

* Open the `.env` file.
* Prisma may add incorrect or duplicated lines due to a known issue.
* Delete the incorrect lines.
* Paste and define the correct `DATABASE_URL`.

---

## 9. MySQL Connection String Format

-------------------code----------------------
DATABASE_URL="mysql://username:password@host:port/database_name"
-------------------code----------------------

### Example Used in This Project

* Username: `root`
* Password: the password set during MySQL installation
* Host: `localhost`
* Port: `3306` (default MySQL port)
* Database name: `review_summarizer`

### Final Example

-------------------code----------------------
DATABASE_URL="mysql://root:your_password@localhost:3306/review_summarizer"
-------------------code----------------------

### What This Does

* Connects Prisma to:

  * The local MySQL server
  * Using the root user
  * Targeting the specified database

---

## 10. Lesson Summary

* Prisma is successfully installed and initialized.
* The application is now connected to MySQL.
* The database connection is configured using environment variables.

---

## 11. Next Lesson

* Define the **structure of the database**:

  * Tables
  * Relationships
  * Fields
* This will be done using the Prisma schema.

---


*** 2.3- Defining the Prisma Schema ***
---

## Lecture Overview: Defining the Prisma Schema

### 1. Purpose of the Prisma Schema

* The Prisma schema defines the **structure of the database** directly in the codebase.
* It specifies:

  * Tables (models)
  * Fields (columns)
  * Data types
  * Relationships between tables

---

## 2. Installing the Prisma VS Code Extension

* Before editing the schema, install the **Prisma extension**.
* Steps:

  * Open the Extensions panel in the editor
  * Search for **Prisma**
  * Install the extension
* Benefits:

  * Syntax highlighting
  * Automatic formatting
  * Autocompletion
  * Improved developer experience

---

## 3. Opening the Schema File

* Open `schema.prisma` in the `prisma` directory.
* This file is where all database models will be defined.

---

## 4. Models to Be Defined

* Three models will be created:

  1. `Product`
  2. `Review`
  3. `Summary`
* Models use **PascalCase naming convention** (first letter uppercase).

---

## 5. Defining the Product Model

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id` (primary key)
    * `@default(autoincrement())`
* `name`

  * Type: `String`
* `description`

  * Type: `String?` (optional)
* `price`

  * Type: `Float`
* `reviews`

  * Type: `Review[]` (one-to-many relationship)
* `summary`

  * Type: `Summary?` (optional one-to-one relationship)

### Notes

* The `id` field uniquely identifies each product.
* Auto-increment allows the database to assign IDs automatically.

---

## 6. Defining the Review Model

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id`
    * `@default(autoincrement())`
* `author`

  * Type: `String`
* `rating`

  * Type: `Int`
* `content`

  * Type: `String`
* `createdAt`

  * Type: `DateTime`
  * Attribute:

    * `@default(now())`
* `productId`

  * Type: `Int`
* `product`

  * Type: `Product`
  * Attribute:

    * `@relation(fields: [productId], references: [id])`

### Relationship Explanation

* Each review belongs to a single product.
* The `productId` field references the `id` field in the `Product` model.
* This creates a **one-to-many relationship**:

  * One product → many reviews

---

## 7. Defining the Summary Model

### Purpose

* Stores AI-generated summaries for products.
* Each summary belongs to exactly one product.

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id`
    * `@default(autoincrement())`
* `productId`

  * Type: `Int`
  * Attribute:

    * `@unique`
* `product`

  * Type: `Product`
  * Attribute:

    * `@relation(fields: [productId], references: [id])`
* `content`

  * Type: `String`
* `generatedAt`

  * Type: `DateTime`
  * Attribute:

    * `@default(now())`
* `expiresAt`

  * Type: `DateTime`

### Relationship Explanation

* This is a **one-to-one relationship**:

  * One product → one summary
* The `@unique` attribute on `productId` is required to enforce one-to-one behavior.
* The `summary` field in the `Product` model is optional because:

  * A product may not yet have reviews or a summary.

---

## 8. Common Schema Errors and Fixes

### Missing Opposite Relationship

* Prisma requires relationships to be defined on both models.
* Fix by adding:

  * `reviews` and `summary` fields to the `Product` model

### One-to-One Relation Error

* Error: one-to-one relations require unique fields.
* Fix:

  * Add `@unique` to `productId` in the `Summary` model

---

## 9. Formatting the Schema

* Save the file to auto-format.
* If formatting does not work:

  * Open the command palette
  * Select **Format Document**
  * Choose **Prisma** as the formatter

---

## 10. Lesson Summary

* Database structure is now fully defined using Prisma.
* Models, fields, and relationships are clearly specified.
* The schema is ready to be used to generate database tables.

---

## 11. Next Lesson

* Use the Prisma schema to **generate actual database tables**.
* Apply the schema to the MySQL database.

---
-------------------code----------------------
model Product {
  id          Int       @id @default(autoincrement())
  name        String
  description String?
  price       Float

  reviews     Review[]
  summary     Summary?
}

model Review {
  id        Int      @id @default(autoincrement())
  author    String
  rating    Int
  content   String
  createdAt DateTime @default(now())

  productId Int
  product   Product  @relation(fields: [productId], references: [id])
}

model Summary {
  id          Int      @id @default(autoincrement())
  productId   Int      @unique
  product     Product  @relation(fields: [productId], references: [id])
  content     String
  generatedAt DateTime @default(now())
  expiresAt   DateTime
}
-------------------code----------------------