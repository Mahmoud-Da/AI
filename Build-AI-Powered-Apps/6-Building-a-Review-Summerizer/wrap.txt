*** 1- Introduction ***
---

## Lecture Overview: Product Review Summarizer Project

### 1. Project Introduction

* This section introduces a more advanced and engaging project.
* The goal is to build a **product review summarizer**.
* Users can generate a concise summary instead of reading all individual reviews.

### 2. User Experience Flow

* A product page displays:

  * A list of user reviews for a product.
  * A button to summarize the reviews.
* When the user clicks the **Summarize Reviews** button:

  * A summary is generated automatically.
  * The summary helps users quickly understand overall feedback.

### 3. Summary Persistence

* Once the summary is generated:

  * It is stored in the database.
  * When the user revisits the page, the summary is retrieved from the database.
  * The summary does **not** need to be regenerated each time.
* This improves:

  * Performance
  * Cost efficiency
  * User experience

### 4. Common Industry Pattern

* This “generate once, reuse later” pattern is increasingly common in modern applications.
* Especially relevant for:

  * AI-powered features
  * Content summarization
  * Recommendation systems

### 5. Project Complexity

* This project is more complex than the previous chatbot project.
* It is a **full-stack application**, involving:

  * Frontend (user interface)
  * Backend (business logic)
  * Database (data storage)

### 6. Database Introduction

* The project uses a database to store summaries.
* Prior database knowledge is **not required**.
* The instructor will cover:

  * Essential database concepts
  * Only what is necessary for this project

### 7. Learning Mindset

* The project is meant to be built step by step.
* Learners are encouraged to:

  * Take their time
  * Follow along carefully
  * Treat this as a hands-on learning experience

---


*** 2- Setting Up the Database ***
---

## Lecture Overview: Database Setup for the Project

### 1. Project Complexity

* This project is more complex than the previously built chatbot project.
* It is a **full-stack application**.
* The application includes its **own database**, which is a core component of the system.

### 2. Purpose of This Segment

* The focus of this segment is on **setting up the database from scratch**.
* The database will serve as the foundation for the rest of the application.

### 3. Database Initialization

* The database will be:

  * Created from the ground up
  * Properly structured to support application features

### 4. Populating the Database

* The database will be filled with **realistic sample data**.
* This ensures:

  * Meaningful testing
  * More realistic development scenarios
  * Better understanding of how the application behaves with real data

### 5. Role of the Database in Development

* Having realistic data allows developers to:

  * Build features more effectively
  * Test logic and edge cases
  * Develop and debug the application with confidence

### 6. Next Steps

* With the database in place and populated:

  * The rest of the application can be built on top of it
  * Backend and frontend features can be developed incrementally

---


*** 2.1- Setting Up MySQL ***
---

## Lecture Overview: Database Setup with MySQL

### 1. Purpose of This Step

* Before building the API, a database must be set up.
* The database will store:

  * Products
  * Reviews
  * Generated summaries
* This database is a foundational part of the application.

### 2. Database Technology Choice

* The project uses **MySQL**.
* MySQL is:

  * Open source
  * A relational database system
  * Widely used in real-world production applications

### 3. Installation Options

* If MySQL is already installed locally:

  * You can continue using the existing installation.
* If MySQL is not installed:

  * Download and install it from the official website.

### 4. Downloading MySQL

* Open a browser and go to **mysql.com**.
* Navigate to the **Downloads** section.
* Scroll to the bottom and select **MySQL Community Downloads**.
* Click on **MySQL Community Server**.
* Choose the latest version for your operating system.

#### Mac-Specific Notes

* Select the correct package based on CPU architecture:

  * ARM (Apple Silicon)
  * x86 (Intel CPUs)
* On the download page:

  * No login or signup is required.
  * Click **“No thanks, just start my download”**.

### 5. Installing MySQL

* Open the installer once the download completes.
* Follow the installation steps:

  * Click **Continue**
  * Agree to the license terms
  * Proceed with installation
* When prompted:

  * Enter your computer’s login password.
* Set a password for the **root (admin) MySQL user**.

  * This password is important and will be used later in the application.
  * Make sure to remember it.
* Complete the installation.
* Enter your computer password again if requested.
* After installation, the installer file can be moved to trash.

### 6. Verifying the Installation

* Open a terminal window.
* Run the following command:
-------------------code----------------------
mysql -u root -p
-------------------code----------------------

* Press Enter.
* When prompted:

  * Enter the MySQL root password you created during installation.
* If the MySQL shell opens successfully:

  * MySQL is installed correctly.

### 7. Exiting the MySQL Shell

* To exit the MySQL shell:

  * Type `quit`
  * Press Enter

### 8. Next Step

* With MySQL installed and verified:

  * The next step is to set up **Prisma**
  * Prisma will be used to interact with the database from the application

---

*** 2.2- Setting Up Prisma ***
---

## Lecture Overview: Connecting MySQL to the Application Using Prisma

### 1. Goal of This Lesson

* Now that MySQL is running, the next step is to connect the application to the database.
* This connection will be handled using **Prisma**.

---

## 2. What Is Prisma?

* Prisma is an **ORM (Object Relational Mapping) tool**.
* It sits between:

  * The application code
  * The database
* Prisma acts like a translator:

  * Converts application code into database queries
  * Provides a clean and type-safe way to interact with the database

---

## 3. Preparing the Project

* Open a terminal window.
* Navigate to the **server directory** of the project.
* Two Prisma-related packages need to be installed:

  * One for development
  * One for runtime usage

---

## 4. Installing Prisma Dependencies

### 4.1 Install Prisma CLI (Development Dependency)

* Run the following command:
-------------------code----------------------
bun add -d prisma
-------------------code----------------------
* Purpose:

  * Provides a command-line interface
  * Used to create and manage the database schema

### 4.2 Install Prisma Client (Runtime Dependency)

* Run:
-------------------code----------------------
bun add @prisma/client
-------------------code----------------------
* Purpose:

  * Allows the application code to communicate with the database

---

## 5. Initializing Prisma

* Run the following command in the server directory:

-------------------code----------------------
bunx prisma init
-------------------code----------------------
* This initializes Prisma for the project.

### Result of Initialization

* A new directory named **prisma** is created.
* Inside it, a **schema file** is generated.

---

## 6. Understanding the Prisma Schema File

* The schema file contains two main sections:

  1. **Client definition**

     * Specifies how Prisma generates the client
  2. **Database definition**

     * Specifies which database is being used and how to connect to it

---

## 7. Configuring Prisma for MySQL

### 7.1 Change Database Provider

* The default provider is set to PostgreSQL.
* Change the provider to **MySQL**.

### 7.2 Database Connection URL

* Prisma uses an environment variable named:

  * `DATABASE_URL`
* Copy this key name.

---

## 8. Updating the Environment File

* Open the `.env` file.
* Prisma may add incorrect or duplicated lines due to a known issue.
* Delete the incorrect lines.
* Paste and define the correct `DATABASE_URL`.

---

## 9. MySQL Connection String Format

-------------------code----------------------
DATABASE_URL="mysql://username:password@host:port/database_name"
-------------------code----------------------

### Example Used in This Project

* Username: `root`
* Password: the password set during MySQL installation
* Host: `localhost`
* Port: `3306` (default MySQL port)
* Database name: `review_summarizer`

### Final Example

-------------------code----------------------
DATABASE_URL="mysql://root:your_password@localhost:3306/review_summarizer"
-------------------code----------------------

### What This Does

* Connects Prisma to:

  * The local MySQL server
  * Using the root user
  * Targeting the specified database

---

## 10. Lesson Summary

* Prisma is successfully installed and initialized.
* The application is now connected to MySQL.
* The database connection is configured using environment variables.

---

## 11. Next Lesson

* Define the **structure of the database**:

  * Tables
  * Relationships
  * Fields
* This will be done using the Prisma schema.

---


*** 2.3- Defining the Prisma Schema ***
---

## Lecture Overview: Defining the Prisma Schema

### 1. Purpose of the Prisma Schema

* The Prisma schema defines the **structure of the database** directly in the codebase.
* It specifies:

  * Tables (models)
  * Fields (columns)
  * Data types
  * Relationships between tables

---

## 2. Installing the Prisma VS Code Extension

* Before editing the schema, install the **Prisma extension**.
* Steps:

  * Open the Extensions panel in the editor
  * Search for **Prisma**
  * Install the extension
* Benefits:

  * Syntax highlighting
  * Automatic formatting
  * Autocompletion
  * Improved developer experience

---

## 3. Opening the Schema File

* Open `schema.prisma` in the `prisma` directory.
* This file is where all database models will be defined.

---

## 4. Models to Be Defined

* Three models will be created:

  1. `Product`
  2. `Review`
  3. `Summary`
* Models use **PascalCase naming convention** (first letter uppercase).

---

## 5. Defining the Product Model

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id` (primary key)
    * `@default(autoincrement())`
* `name`

  * Type: `String`
* `description`

  * Type: `String?` (optional)
* `price`

  * Type: `Float`
* `reviews`

  * Type: `Review[]` (one-to-many relationship)
* `summary`

  * Type: `Summary?` (optional one-to-one relationship)

### Notes

* The `id` field uniquely identifies each product.
* Auto-increment allows the database to assign IDs automatically.

---

## 6. Defining the Review Model

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id`
    * `@default(autoincrement())`
* `author`

  * Type: `String`
* `rating`

  * Type: `Int`
* `content`

  * Type: `String`
* `createdAt`

  * Type: `DateTime`
  * Attribute:

    * `@default(now())`
* `productId`

  * Type: `Int`
* `product`

  * Type: `Product`
  * Attribute:

    * `@relation(fields: [productId], references: [id])`

### Relationship Explanation

* Each review belongs to a single product.
* The `productId` field references the `id` field in the `Product` model.
* This creates a **one-to-many relationship**:

  * One product → many reviews

---

## 7. Defining the Summary Model

### Purpose

* Stores AI-generated summaries for products.
* Each summary belongs to exactly one product.

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id`
    * `@default(autoincrement())`
* `productId`

  * Type: `Int`
  * Attribute:

    * `@unique`
* `product`

  * Type: `Product`
  * Attribute:

    * `@relation(fields: [productId], references: [id])`
* `content`

  * Type: `String`
* `generatedAt`

  * Type: `DateTime`
  * Attribute:

    * `@default(now())`
* `expiresAt`

  * Type: `DateTime`

### Relationship Explanation

* This is a **one-to-one relationship**:

  * One product → one summary
* The `@unique` attribute on `productId` is required to enforce one-to-one behavior.
* The `summary` field in the `Product` model is optional because:

  * A product may not yet have reviews or a summary.

---

## 8. Common Schema Errors and Fixes

### Missing Opposite Relationship

* Prisma requires relationships to be defined on both models.
* Fix by adding:

  * `reviews` and `summary` fields to the `Product` model

### One-to-One Relation Error

* Error: one-to-one relations require unique fields.
* Fix:

  * Add `@unique` to `productId` in the `Summary` model

---

## 9. Formatting the Schema

* Save the file to auto-format.
* If formatting does not work:

  * Open the command palette
  * Select **Format Document**
  * Choose **Prisma** as the formatter

---

## 10. Lesson Summary

* Database structure is now fully defined using Prisma.
* Models, fields, and relationships are clearly specified.
* The schema is ready to be used to generate database tables.

---

## 11. Next Lesson

* Use the Prisma schema to **generate actual database tables**.
* Apply the schema to the MySQL database.

---
-------------------code----------------------
model Product {
  id          Int       @id @default(autoincrement())
  name        String
  description String?
  price       Float

  reviews     Review[]
  summary     Summary?
}

model Review {
  id        Int      @id @default(autoincrement())
  author    String
  rating    Int
  content   String
  createdAt DateTime @default(now())

  productId Int
  product   Product  @relation(fields: [productId], references: [id])
}

model Summary {
  id          Int      @id @default(autoincrement())
  productId   Int      @unique
  product     Product  @relation(fields: [productId], references: [id])
  content     String
  generatedAt DateTime @default(now())
  expiresAt   DateTime
}
-------------------code----------------------

*** 2.4- Running Migrations ***

---

## Creating Database Tables with Prisma Migrations

### 1. Purpose of Migrations

* After defining the **Prisma schema**, the next step is to create the actual database tables.
* This is done using **Prisma migrations**, which:

  * Create or update database tables.
  * Keep the database schema in sync with the codebase.
* Think of migrations like **Git commits**, but for database changes.

---

### 2. Creating the First Migration

#### Steps:

1. Open a terminal pointing to the **server directory**.
2. Run the Prisma CLI migration command:

-------------------code----------------------
bunx prisma migrate dev
-------------------code----------------------

3. Prisma automatically:

   * Creates the database if it does not exist.
   * Detects the schema.
   * Prompts for a migration name.

4. Since this is the first migration, name it:

-------------------code----------------------
init
-------------------code----------------------

#### Best Practice:

* Every time you modify `schema.prisma`, create a **new migration**.
* Use clear, descriptive migration names.

---

### 3. Migration Files Structure

* A new directory is created:

-------------------code----------------------
prisma/
 └── migrations/
     └── 2025xxxxxx_init/
         └── migration.sql
-------------------code----------------------

#### Contents:

* Each migration folder contains:

  * A **timestamp**
  * The **migration name**
  * A `migration.sql` file

#### migration.sql:

* Contains raw SQL instructions.
* In this case:

  * `CREATE TABLE product`
  * `CREATE TABLE review`
  * `CREATE TABLE summary`
* These SQL statements are generated directly from the Prisma models.

---

### 4. Inspecting the Database Using DataGrip

#### Why DataGrip:

* A visual database client by JetBrains.
* Allows you to:

  * Browse tables
  * View data
  * Run SQL queries

#### Notes:

* Commercial software, but:

  * Free trial is available.
* Not affiliated with JetBrains.

#### Download:

* Visit: `jetbrains.com/datagrip`

---

### 5. Connecting DataGrip to MySQL

#### Setup Steps:

1. Open DataGrip and create a new project.
2. Click **+ → Data Source → MySQL**.
3. Enter connection details:

   * Host: `localhost`
   * Port: `3306`
   * User: `root`
   * Password: your MySQL password

#### First-Time Setup:

* You may see a warning about missing MySQL drivers.
* Click the provided link to download them.
* Click **Test Connection** to verify.

---

### 6. Viewing the Database and Tables

* Select the application database (e.g., `review_summarizer`).
* You will see:

  * System databases (used internally by MySQL)
  * Your application database

#### Tables inside the database:

1. `prisma_migrations`
2. `product`
3. `review`
4. `summary`

---

### 7. The prisma_migrations Table

* Used internally by Prisma.
* Tracks:

  * Migration name
  * Timestamp
  * Checksum (for validation)

#### Important:

* **Never modify this table manually**.
* Prisma uses the checksum to detect changes.
* Editing migration files after running them will cause Prisma to fail.

---

### 8. Product Table Structure

#### Columns:

* `id`
* `name`
* `description`
* `price`

#### Column Types:

* `name` is defined as:

-------------------code----------------------
VARCHAR(191)
-------------------code----------------------

#### Explanation:

* `VARCHAR` means variable-length string.
* `191` is Prisma’s default for MySQL.
* This value differs depending on the database engine:

  * MySQL
  * PostgreSQL
  * Others

---

### 9. Naming Conventions in Databases

* Common database practices:

  * Use lowercase table names
  * Use plural names (e.g., `products` instead of `product`)
* Prisma defaults to model-based naming.
* Customization is possible and will be covered later.

---

### 10. Upcoming Improvements

* In modern applications:

  * `VARCHAR(255)` is often preferred over `VARCHAR(191)`.
* In the next lesson:

  * The schema will be customized.
  * A new migration will be created to apply these changes.

---

### Key Takeaways

* Prisma migrations bridge schema definitions and real database tables.
* Each schema change requires a new migration.
* Prisma generates raw SQL automatically.
* Database clients like DataGrip help visualize and verify changes.
* Internal Prisma tables should never be edited manually.

---


Errors:
bunx prisma migrate dev
-------------------code----------------------
Loaded Prisma config from prisma.config.ts.

Prisma schema loaded from prisma/schema.prisma.
Datasource "db": MySQL database "review_summarizer" at "localhost:3306"

Error: P1000: Authentication failed against database server, the provided database credentials for `root` are not valid.

Please make sure to provide valid database credentials for the database server at the configured address.
-------------------code----------------------

- first check the sql uf running
-------------------code----------------------
$ brew services list
Name              Status  User            File
mongodb-community started mahmouddabbbagh ~/Library/LaunchAgents/homebrew.mxcl.mongodb-community.plist
mysql             none
php               none
postgresql@14     started mahmouddabbbagh ~/Library/LaunchAgents/homebrew.mxcl.postgresql@14.plist
unbound           none
-------------------code----------------------

- to run it 
-------------------code----------------------
$ brew services start mysql
==> Successfully started `mysql` (label: homebrew.mxcl.mysql)
-------------------code----------------------

- check the connection by Connect to MySQL to check root password
-------------------code----------------------
$ mysql -u root

# If you set a password before
$ mysql -u root -p
-------------------code----------------------

- to change the password
1- Connect to MySQL
-------------------code----------------------
mysql -u root -p
-------------------code----------------------

2- Once connected in MySQL shell:
-------------------code----------------------
ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_new_password_here';
FLUSH PRIVILEGES;
exit;
-------------------code----------------------

*** 2.5- Refining the Prisma Schema ***
---

## Refining the Prisma Schema (Best Practices)

### 1. Purpose of This Cleanup

* The goal of this lesson is to **refine and clean up the Prisma schema**.
* These changes are **not required** for the application to function.
* They reflect **real-world database best practices** and improve:

  * Readability
  * Maintainability
  * Long-term scalability

---

### 2. Renaming Database Tables

#### Problem:

* Prisma uses **PascalCase** model names by default.
* Many developers prefer:

  * Lowercase table names
  * Pluralized names

#### Solution: `@@map`

* Prisma allows overriding table names using the `@@map` attribute.

#### Example:

-------------------code----------------------
model Product {
  ...
  @@map("products")
}
-------------------code----------------------

#### Applied Changes:

* `Product` → `products`
* `Review` → `reviews`
* `Summary` → `summaries`

---

### 3. Improving String Data Types

#### Default Behavior:

* Prisma maps `String` to:

-------------------code----------------------
VARCHAR(191)
-------------------code----------------------

* This is a MySQL-specific default.

#### Best Practice:

* Use more standardized lengths for strings.
* Customize column types using the `@db` attribute.

---

### 4. Updated Data Types by Model

#### Product Model

* `name`

  * Changed to `VARCHAR(255)`
* `description`

  * Changed to `TEXT` or alternatively `VARCHAR(1000)`
  * `TEXT` chosen for greater flexibility

-------------------code----------------------
name        String @db.VarChar(255)
description String @db.Text
-------------------code----------------------

---

#### Review Model

* `author`

  * Changed to `VARCHAR(255)`
* `rating`

  * Changed from `Int` to `TINYINT`
  * Reason:

    * Ratings only range from 1 to 5
    * `Int` is unnecessarily large (up to 2 billion)

-------------------code----------------------
author String @db.VarChar(255)
rating Int    @db.TinyInt
content String @db.Text
-------------------code----------------------

---

#### Summary Model

* `content`

  * Changed to `TEXT`

-------------------code----------------------
content String @db.Text
-------------------code----------------------

---

### 5. Applying the Changes

#### Steps:

1. Save the updated `schema.prisma`
2. Prisma automatically reformats the file
3. Create a new migration:

-------------------code----------------------
bunx prisma migrate dev
-------------------code----------------------

4. When prompted, name the migration:

-------------------code----------------------
refine-schema
-------------------code----------------------

---

### 6. Migration Results

#### Migration Folder:

* A new directory appears under:

-------------------code----------------------
prisma/migrations/
-------------------code----------------------

* It contains:

  * Timestamp
  * Migration name (`refine-schema`)
  * SQL file with table update instructions

---

### 7. Verifying Changes in the Database

#### In DataGrip:

* Refresh the database view
* Confirm:

  * Table names are now lowercase and plural
  * Column types are updated:

    * `name` → `VARCHAR(255)`
    * `description` → `TEXT`

#### prisma_migrations Table:

* Shows the second migration as applied
* Confirms schema changes were successfully executed

---

### 8. Key Takeaways

* Prisma allows full control over:

  * Table names
  * Column types
* Using `@@map` and `@db` improves database design quality
* Small refinements early prevent technical debt later
* Every schema change must be followed by a migration

---

### 9. Next Lesson Preview

* The next lesson will focus on **populating the database with sample data**.

---


*** 2.6- Populating the Database with Realistic Data ***
---

## Populating the Database with Sample Data

### 1. Goal of This Lesson

* Populate the database with **realistic sample data**.
* This data will be used while developing and testing the application.
* Instead of writing SQL manually, we use **AI assistance** to work faster and smarter.

---

### 2. Why Use AI for Sample Data

* Writing large SQL insert scripts manually is time-consuming.
* AI can:

  * Generate realistic data
  * Follow schema constraints
  * Speed up development
* This demonstrates how AI helps developers beyond just writing application code.

---

### 3. Providing Context to ChatGPT

#### Step 1: Share the Prisma Schema

* Copy the entire `schema.prisma` file.
* Paste it into the prompt.
* This gives AI full context about:

  * Tables
  * Columns
  * Relationships
  * Data types

---

### 4. Writing an Effective Prompt

#### Core Instruction:

* Ask for a **complete SQL script** to populate tables.

Example instruction:

* Generate a complete SQL script to populate the `products` and `reviews` tables in a MySQL database based on the schema above.

---

### 5. Important Prompt Details

#### Specify the Database Engine

* Explicitly mention **MySQL**.
* If not specified, AI may default to PostgreSQL.
* PostgreSQL SQL syntax may not work in MySQL.

#### Limit the Scope

* Only populate:

  * `products`
  * `reviews`
* Do not include:

  * `summaries` table
* Reason:

  * Summaries are generated dynamically by AI at runtime.

---

### 6. Refining the Prompt with Constraints

Additional instructions improve quality and relevance.

Example refinements:

* Create 5 products.
* For each product, insert 5 realistic customer reviews.
* Ensure each review is:

  * Long
  * Relevant to the product type
* Do not include data for the `summaries` table.
* Output only the SQL script.
* Do not include comments or explanations.

#### Key Principle:

* The more specific and descriptive the prompt, the better the output.

---

### 7. Generated Sample Data

#### Result:

* 5 products created:

  * Chair
  * Smartwatch
  * Coffee maker
  * Earphones
  * Scooter
* 25 reviews total:

  * 5 reviews per product
* Reviews are realistic and tailored to each product.

---

### 8. Executing the SQL Script in DataGrip

#### Steps:

1. Open DataGrip.
2. Right-click the application database.
3. Select **New Query Console**.
4. Paste the generated SQL script.
5. Select all:

   * macOS: `Command + A`
   * Windows: `Ctrl + A`
6. Execute the script.

---

### 9. Verifying the Data

#### Results:

* `products` table contains 5 realistic entries.
* `reviews` table contains 25 reviews.
* Data is consistent and ready for development use.

---

### 10. Key Takeaways

* AI is an effective tool for generating realistic test data.
* Well-written prompts lead to higher-quality output.
* Always specify:

  * Database engine
  * Target tables
  * Output format
* Sample data enables faster backend development and testing.

---

### 11. Next Steps

* With realistic data in place, the project is now ready to move on to **building the backend**.

---

## ChatGPT Prompt Template: Generate SQL Seed Data from Prisma Schema

### Context

-------------------code----------------------
Here is my Prisma schema:

<PASTE YOUR FULL schema.prisma HERE>


### Instructions

Based on the Prisma schema above, generate a complete SQL script to populate a MySQL database.

Requirements:
- Database engine: MySQL
- Populate ONLY the following tables:
  - products
  - reviews
- Do NOT include any data for the summaries table
- Create exactly 5 products
- For each product, insert exactly 5 realistic customer reviews
- Reviews must be:
  - Long and detailed
  - Relevant and tailored to the specific product type
- Ensure all foreign key relationships are valid
- Use realistic values for names, descriptions, ratings, and content

Output rules:
- Output ONLY the SQL script
- Do NOT include explanations, comments, or markdown
- The script must be directly executable in MySQL
-------------------code----------------------


- full Example:

-------------------code----------------------
Here is my Prisma schema:

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "mysql"
}

model Product {
  id          Int     @id @default(autoincrement())
  name        String  @db.VarChar(255)
  description String? @db.Text
  price       Float

  reviews Review[]
  summary Summary?

  @@map("products")
}

model Review {
  id        Int      @id @default(autoincrement())
  author    String   @db.VarChar(255)
  rating    Int      @db.TinyInt
  content   String   @db.Text
  createdAt DateTime @default(now())

  productId Int
  product   Product @relation(fields: [productId], references: [id])

  @@map("reviews")
}

model Summary {
  id          Int      @id @default(autoincrement())
  productId   Int      @unique
  product     Product  @relation(fields: [productId], references: [id])
  content     String   @db.Text
  generatedAt DateTime @default(now())
  expiresAt   DateTime

  @@map("summaries")
}



### Instructions

Based on the Prisma schema above, generate a complete SQL script to populate a MySQL database.

Requirements:
- Database engine: MySQL
- Populate ONLY the following tables:
  - products
  - reviews
- Do NOT include any data for the summaries table
- Create exactly 5 products
- For each product, insert exactly 5 realistic customer reviews
- Reviews must be:
  - Long and detailed
  - Relevant and tailored to the specific product type
- Ensure all foreign key relationships are valid
- Use realistic values for names, descriptions, ratings, and content

Output rules:
- Output ONLY the SQL script
- Do NOT include explanations, comments, or markdown
- The script must be directly executable in MySQL
-------------------code----------------------


- result:
-------------------code----------------------
INSERT INTO products (name, description, price) VALUES
('iPhone 15 Pro', 'The latest flagship smartphone from Apple featuring A17 Pro chip, titanium design, 48MP main camera, and Dynamic Island.', 999.99),
('Samsung Odyssey G9 Gaming Monitor', '49-inch dual QHD curved gaming monitor with 240Hz refresh rate, 1ms response time, and NVIDIA G-Sync compatibility.', 1299.99),
('Dyson V15 Detect Cordless Vacuum', 'High-power cordless vacuum with laser dust detection, HEPA filtration, and intelligent suction adjustment.', 749.99),
('Nintendo Switch OLED', 'Gaming console with 7-inch OLED screen, enhanced audio, 64GB internal storage, and adjustable stand.', 349.99),
('Instant Pot Duo Plus 9-in-1', '9-quart multi-use programmable pressure cooker with 15 safety features and 14 one-touch smart programs.', 129.99);

INSERT INTO reviews (author, rating, content, createdAt, productId) VALUES
('Sarah Johnson', 5, 'Absolutely love my new iPhone 15 Pro! The titanium build feels premium and surprisingly lightweight. The camera system is phenomenal - the 48MP main sensor captures incredible detail, and the low-light performance is the best I''ve seen on any smartphone. The A17 Pro chip makes everything buttery smooth, from gaming to video editing. Face ID is faster than ever, and the battery life easily gets me through a full day of heavy use. The Dynamic Island is actually useful for tracking deliveries and music playback. Worth every penny!', '2024-01-15 10:30:00', 1),
('Michael Chen', 4, 'Great phone overall with some minor quirks. The performance is exceptional and the camera upgrades are noticeable, especially the 5x optical zoom. However, the phone does get warm during extended gaming sessions, and the USB-C transition means I had to replace all my cables. The Action Button is customizable but I wish it had more functionality options. Battery life is solid but not groundbreaking compared to previous models. Still, one of the best phones on the market right now.', '2024-01-18 14:22:00', 1),
('Jessica Williams', 5, 'Coming from iPhone 12, this feels like a massive upgrade. The 120Hz ProMotion display is incredibly smooth, making everything feel more responsive. The photos it takes are professional-level - I''ve stopped carrying my DSLR for casual outings. The build quality is outstanding, and the new matte finish doesn''t show fingerprints. The satellite connectivity for emergencies gives me peace of mind when hiking. The only downside is the price, but if you keep your phones for 3-4 years, it''s justified.', '2024-01-20 09:15:00', 1),
('Robert Miller', 3, 'Good phone but overheating issues are concerning. During my first week, the phone got uncomfortably hot during video calls and while charging. The camera produces excellent photos but the processing is sometimes too aggressive, making skin tones look unnatural. The titanium frame is nice but I actually preferred the stainless steel of previous Pro models. Performance is top-notch and iOS 17 runs flawlessly. It''s a good phone but not the revolutionary upgrade I was expecting.', '2024-01-22 16:45:00', 1),
('Amanda Davis', 4, 'The iPhone 15 Pro is a solid evolution of the iPhone formula. The USB-C port is finally here and it''s so convenient to use one cable for all my devices. The camera improvements are substantial, particularly the portrait mode with focus control after taking photos. The battery life has been reliable for my moderate usage pattern. My only complaints are the lack of significant design changes and that the base storage should be 256GB at this price point. Overall, very satisfied with my purchase.', '2024-01-25 11:30:00', 1),
('Alex Thompson', 5, 'This monitor is an absolute game-changer for both work and gaming. The 49-inch super ultrawide display gives me incredible immersion in racing sims and flight simulators. The 240Hz refresh rate with 1ms response time eliminates all motion blur - everything looks crystal clear even in fast-paced shooters. The curve is perfect and reduces eye strain during long sessions. Productivity is through the roof - I can have three full windows side by side. Picture-by-picture mode lets me connect two computers simultaneously. Best tech purchase I''ve made in years!', '2024-01-16 13:20:00', 2),
('David Wilson', 4, 'Impressive display with minor quality control issues. The size and curvature create an incredibly immersive experience, and HDR content looks stunning with deep blacks and vibrant colors. However, I experienced some backlight bleed in the bottom corners, which is noticeable in dark scenes. The stand takes up a lot of desk space but is very sturdy. Setup was straightforward and the on-screen display is intuitive. Gaming performance is exceptional - no tearing or stuttering with G-Sync enabled. Worth it if you get a good panel.', '2024-01-19 15:40:00', 2),
('Jennifer Lee', 5, 'As a video editor and graphic designer, this monitor has transformed my workflow. The color accuracy is outstanding right out of the box, covering 95% of DCI-P3 color space. Having my entire timeline, effects panel, and preview window all visible simultaneously saves me hours each week. The 5120x1440 resolution provides sharp text and detailed images. Gaming is incredible - the field of view in racing games makes me feel like I''m actually in the car. The only drawback is that it requires a powerful GPU to drive at full resolution and refresh rate.', '2024-01-21 10:10:00', 2),
('Thomas Brown', 3, 'Good monitor but has some limitations. The picture quality is excellent and the curve reduces eye strain, but I''ve encountered occasional flickering issues with certain applications. The monitor runs quite hot after several hours of use. The lack of built-in KVM switch is disappointing at this price point. The stand doesn''t have height adjustment, which might be an issue for some setups. Gaming performance is phenomenal when it works properly, but I''ve had to exchange my first unit due to dead pixels. Buyer beware of quality control.', '2024-01-23 18:30:00', 2),
('Emily Carter', 4, 'This monitor delivers an incredible immersive experience for both work and entertainment. The sheer size lets me multitask efficiently with multiple windows visible. Gaming is breathtaking - the curve wraps around your field of vision perfectly. HDR performance is good, though not as bright as some dedicated HDR monitors. The build quality feels premium and the thin bezels look modern. It does require a deep desk and a powerful graphics card. Once calibrated, colors are accurate and consistent across the entire panel. A worthwhile investment for serious users.', '2024-01-26 12:15:00', 2),
('Brian Taylor', 5, 'The Dyson V15 Detect is the best vacuum I''ve ever owned. The laser dust detection feature is revolutionary - it shows exactly where the microscopic dust is that you can''t see with naked eye. The suction power is incredible, picking up everything from pet hair to fine dust. The automatic suction adjustment between different floor types works perfectly. The HEPA filtration means no dust escapes back into the air, which is great for my allergies. Battery life lasts about 60 minutes on medium power, which is enough for my entire house. Worth every cent!', '2024-01-17 08:45:00', 3),
('Karen Martinez', 4, 'Excellent vacuum with a few design quirks. The laser feature is genuinely useful for ensuring you''ve cleaned thoroughly. The various attachments make it versatile for cleaning cars, furniture, and hard-to-reach places. However, the trigger-style power button can be tiring during longer cleaning sessions - I wish it had a toggle lock. The dust bin is easy to empty but sometimes fine dust gets stuck in crevices. The wand telescopes nicely for high ceilings. It''s significantly lighter than my old corded vacuum. Overall, very satisfied despite the premium price.', '2024-01-20 14:20:00', 3),
('Richard Clark', 5, 'As a pet owner with two dogs that shed constantly, this vacuum has been life-changing. The motorbar head doesn''t get tangled with hair like previous vacuums I''ve owned. The laser actually shows all the pet hair and dander I was missing before. The display showing exactly what you''re picking up in real-time is both satisfying and informative. Battery lasts long enough to do my entire 2000 sq ft home on a single charge. The wall mount is sturdy and keeps everything organized. It''s expensive but has saved me on professional cleaning services.', '2024-01-22 11:30:00', 3),
('Lisa Anderson', 3, 'Good vacuum but overhyped in my opinion. The laser feature is cool but after the first few uses, it becomes less necessary. The suction power is strong but not significantly better than competitors at half the price. The battery life diminishes noticeably after 6 months of use. The accessories are high quality but expensive to replace. It does a great job on hard floors but can sometimes scatter debris on low-pile carpets. It''s well-designed and looks premium, but I''m not convinced it''s worth the substantial price premium over other cordless options.', '2024-01-24 16:50:00', 3),
('Daniel White', 4, 'The Dyson V15 makes cleaning less of a chore. The automatic adjustment between different surfaces works surprisingly well, and the laser genuinely helps identify areas that need more attention. The crevice tool is perfect for car interiors. The hygienic bin emptying system is effective and doesn''t create dust clouds. My only complaints are that the battery takes 4-5 hours to fully charge and the vacuum can be top-heavy when using some attachments. For apartments and smaller homes, this is nearly perfect. For larger homes, you might need the extra battery.', '2024-01-27 09:40:00', 3),
('Christopher Lee', 5, 'The Switch OLED is the definitive version of the Nintendo Switch. The 7-inch OLED screen is absolutely stunning - colors pop, blacks are deep, and the improved brightness makes handheld play much more enjoyable. The enhanced speakers provide richer sound for both games and media. The new adjustable stand is sturdy and allows for comfortable tabletop gaming at various angles. The 64GB internal storage is welcome, though I still use a microSD card for my digital library. If you play primarily in handheld mode, this upgrade is absolutely worth it.', '2024-01-18 12:15:00', 4),
('Michelle Garcia', 4, 'Great upgrade for handheld players, less so for docked users. The OLED screen makes games like Metroid Dread and The Legend of Zelda look incredible with vibrant colors and perfect blacks. The improved battery life gives me about 5-6 hours of playtime with Breath of the Wild. The Ethernet port in the dock is convenient for stable online gaming. However, the internal hardware is identical to the original Switch, so don''t expect performance improvements. The white Joy-Cons look sleek but may show dirt more easily. Recommended if you play mostly handheld.', '2024-01-21 15:30:00', 4),
('Kevin Scott', 5, 'As someone who owns all three Switch models, the OLED is hands-down the best for handheld gaming. The screen is significantly larger than the original Switch while maintaining the same device size. Colors are richer and contrast is dramatically better. The improved kickstand makes tabletop mode actually usable in various environments. The speakers are noticeably clearer with better bass response. While it doesn''t offer performance upgrades, the quality-of-life improvements make it the best Switch experience available. Perfect for gaming on the go or around the house.', '2024-01-23 13:45:00', 4),
('Nicole Young', 3, 'Good console but the upgrade feels incremental. The OLED screen is beautiful but only really noticeable side-by-side with the original Switch. The lack of hardware improvements means games still run at the same frame rates and resolutions. The new dock looks nice but functionally identical. Battery life is slightly better but not dramatically so. If you already own a Switch and play mostly docked, there''s little reason to upgrade. For new buyers or those who play primarily handheld, it''s the best option. Wait for a true \"Switch Pro\" if you want performance gains.', '2024-01-25 17:20:00', 4),
('Steven Hall', 4, 'The Switch OLED excels at what it''s designed for - portable and tabletop gaming. The screen is gorgeous, making indie games and first-party Nintendo titles look their absolute best. The new stand is infinitely more useful than the flimsy original. Storage upgrade is appreciated since some games like Doom Eternal are massive downloads. The console feels premium and well-built. My only complaint is that Nintendo didn''t include a screen protector in the box for such an expensive screen. Overall, if you don''t own a Switch yet, this is the version to get.', '2024-01-28 10:55:00', 4),
('Patricia King', 5, 'The Instant Pot Duo Plus has revolutionized my cooking routine. As someone who works long hours, being able to come home and have a healthy meal ready in minutes is incredible. The 9-quart size is perfect for meal prepping or cooking for my family of four. The yogurt function alone has saved me hundreds of dollars compared to store-bought yogurt. The 15 safety features give me peace of mind, especially the lid lock and pressure release indicators. The stainless steel inner pot is durable and dishwasher safe. This has replaced my slow cooker, rice cooker, and steamer!', '2024-01-19 09:30:00', 5),
('Matthew Wright', 4, 'Excellent multi-cooker with a learning curve. The number of functions is impressive - I particularly love the sous vide feature for perfect steaks. The 14 smart programs take the guesswork out of pressure cooking times. However, the controls can be confusing initially, and the manual could be more comprehensive. The keep-warm function works well but sometimes overcooks delicate foods if left too long. Cleanup is easy, though the sealing ring tends to retain odors that need occasional cleaning. Once you master it, this becomes an indispensable kitchen appliance.', '2024-01-22 18:15:00', 5),
('Sandra Lopez', 5, 'This Instant Pot has made cooking from scratch accessible despite my busy schedule. I can make beans from dry in under an hour, tenderize cheap cuts of meat, and cook perfect rice every time. The delay start function lets me prep ingredients in the morning and have dinner ready when I get home. The stainless steel construction feels durable and is BPA-free. The steam release handle is well-designed and prevents accidental burns. I''ve successfully made everything from cheesecake to hard-boiled eggs. The best kitchen investment I''ve made in years - it pays for itself quickly!', '2024-01-24 12:40:00', 5),
('Edward Hill', 3, 'Good pressure cooker but not without flaws. The cooking functions work well and produce delicious meals quickly. However, I''ve experienced inconsistent results with the rice function - sometimes perfect, sometimes mushy. The size is large, which is great for big batches but takes up considerable counter space. The inner pot has hot spots that can cause burning if not enough liquid is used. The display isn''t backlit, making it hard to read in low light. It''s a solid multicooker but I think some of the hype is overblown. Still useful for busy households.', '2024-01-26 14:25:00', 5),
('Rebecca Green', 4, 'The Instant Pot Duo Plus lives up to most of its promises. I use it several times a week for everything from quick weeknight dinners to Sunday meal prep. The pressure cooking function tenderizes meats beautifully and infuses flavors deeply. The sauté function means I can brown meat and then pressure cook all in one pot. The sterilize function has been great for baby bottles. My only complaints are that it takes time to come to pressure and release pressure, and the buttons beep loudly. Overall, it''s a versatile tool that has earned its place in my kitchen.', '2024-01-29 11:10:00', 5);
-------------------code----------------------


# fastest:
1- access the db
-------------------code----------------------
mysql -u root -p review_summarizer
-------------------code----------------------


2- paste the result of the chatGPT above
-------------------code---------------------- 
Query OK, 25 rows affected (0.008 sec)
Records: 25  Duplicates: 0  Warnings: 0
-------------------code----------------------

# other methods:


- how to insert the data
You can add the data directly using your existing database connection. Here are the easiest ways:

## Method 1: Direct MySQL import (Recommended)

1. Save the SQL script to a file:
-------------------code----------------------
echo "INSERT INTO products (name, description, price) VALUES
('iPhone 15 Pro', 'The latest flagship smartphone from Apple featuring A17 Pro chip, titanium design, 48MP main camera, and Dynamic Island.', 999.99),
('Samsung Odyssey G9 Gaming Monitor', '49-inch dual QHD curved gaming monitor with 240Hz refresh rate, 1ms response time, and NVIDIA G-Sync compatibility.', 1299.99),
('Dyson V15 Detect Cordless Vacuum', 'High-power cordless vacuum with laser dust detection, HEPA filtration, and intelligent suction adjustment.', 749.99),
('Nintendo Switch OLED', 'Gaming console with 7-inch OLED screen, enhanced audio, 64GB internal storage, and adjustable stand.', 349.99),
('Instant Pot Duo Plus 9-in-1', '9-quart multi-use programmable pressure cooker with 15 safety features and 14 one-touch smart programs.', 129.99);

INSERT INTO reviews (author, rating, content, createdAt, productId) VALUES
('Sarah Johnson', 5, 'Absolutely love my new iPhone 15 Pro! The titanium build feels premium and surprisingly lightweight. The camera system is phenomenal - the 48MP main sensor captures incredible detail, and the low-light performance is the best I''ve seen on any smartphone. The A17 Pro chip makes everything buttery smooth, from gaming to video editing. Face ID is faster than ever, and the battery life easily gets me through a full day of heavy use. The Dynamic Island is actually useful for tracking deliveries and music playback. Worth every penny!', '2024-01-15 10:30:00', 1),
('Michael Chen', 4, 'Great phone overall with some minor quirks. The performance is exceptional and the camera upgrades are noticeable, especially the 5x optical zoom. However, the phone does get warm during extended gaming sessions, and the USB-C transition means I had to replace all my cables. The Action Button is customizable but I wish it had more functionality options. Battery life is solid but not groundbreaking compared to previous models. Still, one of the best phones on the market right now.', '2024-01-18 14:22:00', 1),
('Jessica Williams', 5, 'Coming from iPhone 12, this feels like a massive upgrade. The 120Hz ProMotion display is incredibly smooth, making everything feel more responsive. The photos it takes are professional-level - I''ve stopped carrying my DSLR for casual outings. The build quality is outstanding, and the new matte finish doesn''t show fingerprints. The satellite connectivity for emergencies gives me peace of mind when hiking. The only downside is the price, but if you keep your phones for 3-4 years, it''s justified.', '2024-01-20 09:15:00', 1),
('Robert Miller', 3, 'Good phone but overheating issues are concerning. During my first week, the phone got uncomfortably hot during video calls and while charging. The camera produces excellent photos but the processing is sometimes too aggressive, making skin tones look unnatural. The titanium frame is nice but I actually preferred the stainless steel of previous Pro models. Performance is top-notch and iOS 17 runs flawlessly. It''s a good phone but not the revolutionary upgrade I was expecting.', '2024-01-22 16:45:00', 1),
('Amanda Davis', 4, 'The iPhone 15 Pro is a solid evolution of the iPhone formula. The USB-C port is finally here and it''s so convenient to use one cable for all my devices. The camera improvements are substantial, particularly the portrait mode with focus control after taking photos. The battery life has been reliable for my moderate usage pattern. My only complaints are the lack of significant design changes and that the base storage should be 256GB at this price point. Overall, very satisfied with my purchase.', '2024-01-25 11:30:00', 1),
('Alex Thompson', 5, 'This monitor is an absolute game-changer for both work and gaming. The 49-inch super ultrawide display gives me incredible immersion in racing sims and flight simulators. The 240Hz refresh rate with 1ms response time eliminates all motion blur - everything looks crystal clear even in fast-paced shooters. The curve is perfect and reduces eye strain during long sessions. Productivity is through the roof - I can have three full windows side by side. Picture-by-picture mode lets me connect two computers simultaneously. Best tech purchase I''ve made in years!', '2024-01-16 13:20:00', 2),
('David Wilson', 4, 'Impressive display with minor quality control issues. The size and curvature create an incredibly immersive experience, and HDR content looks stunning with deep blacks and vibrant colors. However, I experienced some backlight bleed in the bottom corners, which is noticeable in dark scenes. The stand takes up a lot of desk space but is very sturdy. Setup was straightforward and the on-screen display is intuitive. Gaming performance is exceptional - no tearing or stuttering with G-Sync enabled. Worth it if you get a good panel.', '2024-01-19 15:40:00', 2),
('Jennifer Lee', 5, 'As a video editor and graphic designer, this monitor has transformed my workflow. The color accuracy is outstanding right out of the box, covering 95% of DCI-P3 color space. Having my entire timeline, effects panel, and preview window all visible simultaneously saves me hours each week. The 5120x1440 resolution provides sharp text and detailed images. Gaming is incredible - the field of view in racing games makes me feel like I''m actually in the car. The only drawback is that it requires a powerful GPU to drive at full resolution and refresh rate.', '2024-01-21 10:10:00', 2),
('Thomas Brown', 3, 'Good monitor but has some limitations. The picture quality is excellent and the curve reduces eye strain, but I''ve encountered occasional flickering issues with certain applications. The monitor runs quite hot after several hours of use. The lack of built-in KVM switch is disappointing at this price point. The stand doesn''t have height adjustment, which might be an issue for some setups. Gaming performance is phenomenal when it works properly, but I''ve had to exchange my first unit due to dead pixels. Buyer beware of quality control.', '2024-01-23 18:30:00', 2),
('Emily Carter', 4, 'This monitor delivers an incredible immersive experience for both work and entertainment. The sheer size lets me multitask efficiently with multiple windows visible. Gaming is breathtaking - the curve wraps around your field of vision perfectly. HDR performance is good, though not as bright as some dedicated HDR monitors. The build quality feels premium and the thin bezels look modern. It does require a deep desk and a powerful graphics card. Once calibrated, colors are accurate and consistent across the entire panel. A worthwhile investment for serious users.', '2024-01-26 12:15:00', 2),
('Brian Taylor', 5, 'The Dyson V15 Detect is the best vacuum I''ve ever owned. The laser dust detection feature is revolutionary - it shows exactly where the microscopic dust is that you can''t see with naked eye. The suction power is incredible, picking up everything from pet hair to fine dust. The automatic suction adjustment between different floor types works perfectly. The HEPA filtration means no dust escapes back into the air, which is great for my allergies. Battery life lasts about 60 minutes on medium power, which is enough for my entire house. Worth every cent!', '2024-01-17 08:45:00', 3),
('Karen Martinez', 4, 'Excellent vacuum with a few design quirks. The laser feature is genuinely useful for ensuring you''ve cleaned thoroughly. The various attachments make it versatile for cleaning cars, furniture, and hard-to-reach places. However, the trigger-style power button can be tiring during longer cleaning sessions - I wish it had a toggle lock. The dust bin is easy to empty but sometimes fine dust gets stuck in crevices. The wand telescopes nicely for high ceilings. It''s significantly lighter than my old corded vacuum. Overall, very satisfied despite the premium price.', '2024-01-20 14:20:00', 3),
('Richard Clark', 5, 'As a pet owner with two dogs that shed constantly, this vacuum has been life-changing. The motorbar head doesn''t get tangled with hair like previous vacuums I''ve owned. The laser actually shows all the pet hair and dander I was missing before. The display showing exactly what you''re picking up in real-time is both satisfying and informative. Battery lasts long enough to do my entire 2000 sq ft home on a single charge. The wall mount is sturdy and keeps everything organized. It''s expensive but has saved me on professional cleaning services.', '2024-01-22 11:30:00', 3),
('Lisa Anderson', 3, 'Good vacuum but overhyped in my opinion. The laser feature is cool but after the first few uses, it becomes less necessary. The suction power is strong but not significantly better than competitors at half the price. The battery life diminishes noticeably after 6 months of use. The accessories are high quality but expensive to replace. It does a great job on hard floors but can sometimes scatter debris on low-pile carpets. It''s well-designed and looks premium, but I''m not convinced it''s worth the substantial price premium over other cordless options.', '2024-01-24 16:50:00', 3),
('Daniel White', 4, 'The Dyson V15 makes cleaning less of a chore. The automatic adjustment between different surfaces works surprisingly well, and the laser genuinely helps identify areas that need more attention. The crevice tool is perfect for car interiors. The hygienic bin emptying system is effective and doesn''t create dust clouds. My only complaints are that the battery takes 4-5 hours to fully charge and the vacuum can be top-heavy when using some attachments. For apartments and smaller homes, this is nearly perfect. For larger homes, you might need the extra battery.', '2024-01-27 09:40:00', 3),
('Christopher Lee', 5, 'The Switch OLED is the definitive version of the Nintendo Switch. The 7-inch OLED screen is absolutely stunning - colors pop, blacks are deep, and the improved brightness makes handheld play much more enjoyable. The enhanced speakers provide richer sound for both games and media. The new adjustable stand is sturdy and allows for comfortable tabletop gaming at various angles. The 64GB internal storage is welcome, though I still use a microSD card for my digital library. If you play primarily in handheld mode, this upgrade is absolutely worth it.', '2024-01-18 12:15:00', 4),
('Michelle Garcia', 4, 'Great upgrade for handheld players, less so for docked users. The OLED screen makes games like Metroid Dread and The Legend of Zelda look incredible with vibrant colors and perfect blacks. The improved battery life gives me about 5-6 hours of playtime with Breath of the Wild. The Ethernet port in the dock is convenient for stable online gaming. However, the internal hardware is identical to the original Switch, so don''t expect performance improvements. The white Joy-Cons look sleek but may show dirt more easily. Recommended if you play mostly handheld.', '2024-01-21 15:30:00', 4),
('Kevin Scott', 5, 'As someone who owns all three Switch models, the OLED is hands-down the best for handheld gaming. The screen is significantly larger than the original Switch while maintaining the same device size. Colors are richer and contrast is dramatically better. The improved kickstand makes tabletop mode actually usable in various environments. The speakers are noticeably clearer with better bass response. While it doesn''t offer performance upgrades, the quality-of-life improvements make it the best Switch experience available. Perfect for gaming on the go or around the house.', '2024-01-23 13:45:00', 4),
('Nicole Young', 3, 'Good console but the upgrade feels incremental. The OLED screen is beautiful but only really noticeable side-by-side with the original Switch. The lack of hardware improvements means games still run at the same frame rates and resolutions. The new dock looks nice but functionally identical. Battery life is slightly better but not dramatically so. If you already own a Switch and play mostly docked, there''s little reason to upgrade. For new buyers or those who play primarily handheld, it''s the best option. Wait for a true \"Switch Pro\" if you want performance gains.', '2024-01-25 17:20:00', 4),
('Steven Hall', 4, 'The Switch OLED excels at what it''s designed for - portable and tabletop gaming. The screen is gorgeous, making indie games and first-party Nintendo titles look their absolute best. The new stand is infinitely more useful than the flimsy original. Storage upgrade is appreciated since some games like Doom Eternal are massive downloads. The console feels premium and well-built. My only complaint is that Nintendo didn''t include a screen protector in the box for such an expensive screen. Overall, if you don''t own a Switch yet, this is the version to get.', '2024-01-28 10:55:00', 4),
('Patricia King', 5, 'The Instant Pot Duo Plus has revolutionized my cooking routine. As someone who works long hours, being able to come home and have a healthy meal ready in minutes is incredible. The 9-quart size is perfect for meal prepping or cooking for my family of four. The yogurt function alone has saved me hundreds of dollars compared to store-bought yogurt. The 15 safety features give me peace of mind, especially the lid lock and pressure release indicators. The stainless steel inner pot is durable and dishwasher safe. This has replaced my slow cooker, rice cooker, and steamer!', '2024-01-19 09:30:00', 5),
('Matthew Wright', 4, 'Excellent multi-cooker with a learning curve. The number of functions is impressive - I particularly love the sous vide feature for perfect steaks. The 14 smart programs take the guesswork out of pressure cooking times. However, the controls can be confusing initially, and the manual could be more comprehensive. The keep-warm function works well but sometimes overcooks delicate foods if left too long. Cleanup is easy, though the sealing ring tends to retain odors that need occasional cleaning. Once you master it, this becomes an indispensable kitchen appliance.', '2024-01-22 18:15:00', 5),
('Sandra Lopez', 5, 'This Instant Pot has made cooking from scratch accessible despite my busy schedule. I can make beans from dry in under an hour, tenderize cheap cuts of meat, and cook perfect rice every time. The delay start function lets me prep ingredients in the morning and have dinner ready when I get home. The stainless steel construction feels durable and is BPA-free. The steam release handle is well-designed and prevents accidental burns. I''ve successfully made everything from cheesecake to hard-boiled eggs. The best kitchen investment I''ve made in years - it pays for itself quickly!', '2024-01-24 12:40:00', 5),
('Edward Hill', 3, 'Good pressure cooker but not without flaws. The cooking functions work well and produce delicious meals quickly. However, I''ve experienced inconsistent results with the rice function - sometimes perfect, sometimes mushy. The size is large, which is great for big batches but takes up considerable counter space. The inner pot has hot spots that can cause burning if not enough liquid is used. The display isn''t backlit, making it hard to read in low light. It''s a solid multicooker but I think some of the hype is overblown. Still useful for busy households.', '2024-01-26 14:25:00', 5),
('Rebecca Green', 4, 'The Instant Pot Duo Plus lives up to most of its promises. I use it several times a week for everything from quick weeknight dinners to Sunday meal prep. The pressure cooking function tenderizes meats beautifully and infuses flavors deeply. The sauté function means I can brown meat and then pressure cook all in one pot. The sterilize function has been great for baby bottles. My only complaints are that it takes time to come to pressure and release pressure, and the buttons beep loudly. Overall, it''s a versatile tool that has earned its place in my kitchen.', '2024-01-29 11:10:00', 5);" > seed_data.sql
-------------------code----------------------

2. Run the SQL file with MySQL:
-------------------code----------------------
mysql -u root -p review_summarizer < seed_data.sql
-------------------code----------------------

## Method 2: Using Prisma Client in your application

Create a seed script (`prisma/seed.ts` or `prisma/seed.js`):

-------------------code----------------------
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // Clear existing data (optional)
  await prisma.review.deleteMany()
  await prisma.summary.deleteMany()
  await prisma.product.deleteMany()

  // Create products
  const products = await prisma.product.createMany({
    data: [
      {
        name: 'iPhone 15 Pro',
        description: 'The latest flagship smartphone from Apple featuring A17 Pro chip, titanium design, 48MP main camera, and Dynamic Island.',
        price: 999.99
      },
      {
        name: 'Samsung Odyssey G9 Gaming Monitor',
        description: '49-inch dual QHD curved gaming monitor with 240Hz refresh rate, 1ms response time, and NVIDIA G-Sync compatibility.',
        price: 1299.99
      },
      {
        name: 'Dyson V15 Detect Cordless Vacuum',
        description: 'High-power cordless vacuum with laser dust detection, HEPA filtration, and intelligent suction adjustment.',
        price: 749.99
      },
      {
        name: 'Nintendo Switch OLED',
        description: 'Gaming console with 7-inch OLED screen, enhanced audio, 64GB internal storage, and adjustable stand.',
        price: 349.99
      },
      {
        name: 'Instant Pot Duo Plus 9-in-1',
        description: '9-quart multi-use programmable pressure cooker with 15 safety features and 14 one-touch smart programs.',
        price: 129.99
      }
    ]
  })

  // Create reviews for each product
  const reviewsData = [
    // Product 1 reviews...
    // (Copy all the review data from the SQL script)
  ]

  await prisma.review.createMany({
    data: reviewsData
  })
}

main()
  .catch((e) => {
    console.error(e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
-------------------code----------------------

Then run it:
-------------------code----------------------
bunx ts-node prisma/seed.ts
# or if using bun
bun prisma/seed.ts
-------------------code----------------------

## Method 3: Quick MySQL command line

Copy the entire SQL script and paste it directly into MySQL:

-------------------code----------------------
mysql -u root -p review_summarizer
-------------------code----------------------

Then paste the entire INSERT statements and press Enter.

## Method 4: Using a GUI tool (easiest)

1. Install **TablePlus**, **MySQL Workbench**, or **Sequel Ace**
2. Connect to your MySQL database
3. Open a new query window
4. Paste the entire SQL script
5. Click "Execute" or "Run"

**Recommendation:** Use **Method 1** (SQL file import) - it's the simplest and most reliable. Just save the SQL script and run one command.

*** 3- Building the Backend ***
---

## Transition to Backend Development

### 1. Current Project Status

* The database schema is finalized.
* Migrations have been applied successfully.
* Tables are populated with realistic sample data.
* The project is now ready for backend development.

---

### 2. Goal of This Phase

* Build the **backend layer** of the application.
* Expose functionality through API endpoints.
* Prepare the codebase for future refactoring and scalability.

---

### 3. Planned Backend Features

#### API Endpoints

* Create endpoints for:

  * Fetching product reviews
  * Generating summaries from reviews

#### Responsibilities of the Backend

* Retrieve review data from the database.
* Process and summarize reviews.
* Return structured responses to the client.

---

### 4. Development Approach

#### Step 1: Implement Core Functionality

* Focus on making the backend work end-to-end.
* Prioritize correctness over code cleanliness at this stage.

#### Step 2: Refactor

* Once functionality is complete:

  * Clean up the code
  * Improve structure and readability
  * Make the code easier to maintain and extend

---

### 5. Key Takeaways

* Backend development begins only after data and schema are stable.
* Building first, then refactoring, leads to faster progress.
* Clear separation between functionality and optimization improves development flow.

---

### 6. Next Steps

* Start implementing backend endpoints.
* Connect endpoints to the database.
* Add logic for summarizing reviews.

---

*** 3.1- Creating the API to Fetch Reviews ***


---

## Building the First API Endpoint: Fetch Product Reviews

### 1. Objective of This Lesson

* Build the **first backend API endpoint**.
* Fetch all reviews for a specific product.
* Start with a simple implementation, then improve it through refactoring and modularization.

---

### 2. Development Strategy

* Implement a **basic working version** first.
* Validate functionality using real data.
* Refactor after confirming correct behavior.

---

### 3. Route Definition

#### File:

* `routes.ts`

#### Endpoint:

-------------------code----------------------
GET /api/products/:id/reviews
-------------------code----------------------

#### Notes:

* `:id` is a **route parameter**.
* Route parameters are defined using a colon followed by the parameter name.

---

### 4. Route Handler Setup

#### Handler Signature:

* Function with two parameters:

  * `req` of type `Request`
  * `res` of type `Response`

---

### 5. Prisma Client Initialization

#### Import Location:

* Import `PrismaClient` from the **generated Prisma client** directory:

  -------------------code----------------------
  ./generated/prisma
  -------------------code----------------------

#### Reason:

* Prisma regenerates the client every time:

  * The schema changes
  * A new migration is created
* Importing from the generated folder ensures the client always matches the schema.

#### Initialization:

* Create a new Prisma client instance inside the route module.

---

### 6. Reading and Parsing the Product ID

#### Steps:

1. Read the product ID from the URL:

   -------------------code----------------------
   req.params.id
   -------------------code----------------------
2. The type is `string | undefined`.
3. Convert it to a number using:

   -------------------code----------------------
   Number(req.params.id)
   -------------------code----------------------

---

### 7. Fetching Reviews (Happy Path)

#### Prisma Query:

* Use `prisma.review.findMany`

#### Query Customization:

* `where`:

  * Filter reviews by `productId`
* `orderBy`:

  * Sort by `createdAt`
  * Descending order (latest reviews first)

#### Result:

* Prisma generates a SQL query similar to:

  -------------------code----------------------
  SELECT * FROM reviews
  WHERE productId = ?
  ORDER BY createdAt DESC
  -------------------code----------------------

---

### 8. ORM Benefits and Limitations

#### Benefits:

* No need to write raw SQL for simple queries.
* Work with objects instead of SQL syntax.
* Cleaner and more maintainable code.

#### Limitations:

* ORMs are not a replacement for SQL knowledge.
* Complex queries may still require raw SQL.

---

### 9. Async Handling

* `findMany` returns a **Promise**.
* Use `await` to retrieve results.
* Mark the route handler as `async`.

---

### 10. Sending the Response

* The result is an array of review objects.
* Each object includes:

  * `id`
  * `author`
  * `rating`
  * `content`
  * `createdAt`
* Return the data using:

  -------------------code----------------------
  res.json(reviews)
  -------------------code----------------------

---

### 11. Testing with Postman

#### Request:

-------------------code----------------------
GET http://localhost:3000/api/products/1/reviews
-------------------code----------------------

#### Expected Result:

* JSON array of reviews for product ID `1`.

#### Invalid Product ID (Non-existent but numeric):

-------------------code----------------------
/api/products/10/reviews
-------------------code----------------------

* Response: empty array
* Acceptable behavior.

---

### 12. Handling Invalid Input

#### Problem:

* Non-numeric product IDs cause a `500 Internal Server Error`.
* This indicates a server crash and must be avoided.

---

### 13. Input Validation

#### Validation Logic:

* Check if `productId` is `NaN`.

#### Two Possible Responses:

1. Return an empty list
2. Return a `400 Bad Request` error

---

### 14. Choosing the Correct Error Strategy

#### Reasoning:

* Returning an empty list can hide frontend bugs.
* A `400 Bad Request`:

  * Clearly signals invalid input
  * Helps detect frontend issues early

#### Implementation:

* If product ID is invalid:

  * Return status `400`
  * Send an error message:

    -------------------code----------------------
    { error: "Invalid product id" }
    -------------------code----------------------
  * Stop further execution using `return`.

---

### 15. Retesting After Validation

#### Request:

-------------------code----------------------
GET /api/products/abc/reviews
-------------------code----------------------

#### Result:

* Status code: `400`
* Error message: `Invalid product id`

---

### 16. Final Outcome

* The endpoint:

  * Fetches reviews correctly
  * Sorts them properly
  * Handles invalid input safely
* Backend stability is improved.
* Frontend bugs become easier to detect.

---

### 17. Next Steps

* Refactor the route code.
* Improve structure and modularity.
* Prepare for additional endpoints and features.

---



How to fix prisma if not initialized well:

PrismaClientInitializationError: `PrismaClient` needs to be constructed with a non-empty, valid `PrismaClientOptions`:
[server]

to fix:
return to prisma 6 and @prisma/client 6
-------------------code----------------------
{
  "name": "server",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "devDependencies": {
    "@types/bun": "latest",
    "@types/express": "^5.0.5",
    "prisma": "^6.2.0"
  },
  "scripts": {
    "start": "bun run index.ts",
    "dev": "bun --watch run index.ts"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@prisma/client": "^6.2.0",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "openai": "^6.9.1",
    "zod": "^4.1.13"
  }
}
-------------------code----------------------

for the schema 
-------------------code----------------------
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider   = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Product {
  id          Int     @id @default(autoincrement())
  name        String  @db.VarChar(255)
  description String? @db.Text
  price       Float

  reviews Review[]
  summary Summary?

  @@map("products")
}

model Review {
  id        Int      @id @default(autoincrement())
  author    String   @db.VarChar(255)
  rating    Int      @db.TinyInt
  content   String   @db.Text
  createdAt DateTime @default(now())

  productId Int
  product   Product @relation(fields: [productId], references: [id])

  @@map("reviews")
}

model Summary {
  id          Int      @id @default(autoincrement())
  productId   Int      @unique
  product     Product  @relation(fields: [productId], references: [id])
  content     String   @db.Text
  generatedAt DateTime @default(now())
  expiresAt   DateTime

  @@map("summaries")
}
-------------------code----------------------

*** 3.2- Refactoring- Separation of Concerns ***

---

## Refactoring the Reviews Endpoint (Modular Architecture)

### Goal

Refactor the existing reviews endpoint by:

* Separating concerns
* Introducing **Controller**, **Service**, and **Repository** layers
* Improving maintainability and clarity

---

## Application Layers Recap

* **Controller**

  * Handles HTTP requests and responses
  * Validates inputs
  * Calls services

* **Service**

  * Contains business logic
  * Coordinates between controller and repository

* **Repository**

  * Handles data access
  * Communicates directly with Prisma / database

---

## Step 1: Create the Review Controller

### File

-------------------code----------------------
controllers/review.controller.ts
-------------------code----------------------

### Responsibilities

* Handle HTTP requests
* Validate `productId`
* Call the service
* Return HTTP responses

### Code

-------------------code----------------------
import type { Request, Response } from "express";
import { reviewService } from "../services/review.service";

export const reviewController = {
  async getReviews(req: Request, res: Response) {
    const productId = Number(req.params.id);

    if (isNaN(productId)) {
      return res.status(400).json({ error: "Invalid product ID" });
    }

    const reviews = await reviewService.getReviews(productId);
    res.json(reviews);
  },
};
-------------------code----------------------

---

## Step 2: Update Routes Module

### File

-------------------code----------------------
routes.ts
-------------------code----------------------

### Change

Replace inline logic with the controller method.

### Code

-------------------code----------------------
import { reviewController } from "./controllers/review.controller";



router.get("/api/products/:id/reviews", reviewController.getReviews);
-------------------code----------------------

---

## Step 3: Introduce the Review Service

### Purpose

Move business logic out of the controller.

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

### Responsibilities

* Accept `productId`
* Return reviews
* Call repository

### Code

-------------------code----------------------
import type { Review } from "@prisma/client";
import { reviewRepository } from "../repositories/review.repository";

export const reviewService = {
  getReviews(productId: number): Promise<Review[]> {
    return reviewRepository.getReviews(productId);
  },
};
-------------------code----------------------

---

## Step 4: Introduce the Review Repository

### Why?

Data access logic should not live in services.

### File

-------------------code----------------------
repositories/review.repository.ts
-------------------code----------------------

### Responsibilities

* Query the database
* Use Prisma directly

### Code

-------------------code----------------------
import { PrismaClient, type Review } from "@prisma/client";

export const reviewRepository = {
  getReviews(productId: number): Promise<Review[]> {
    const prisma = new PrismaClient();

    return prisma.review.findMany({
      where: { productId },
      orderBy: { createdAt: "desc" },
    });
  },
};

-------------------code----------------------

---

## Final Architecture Flow

-------------------code----------------------
HTTP Request
   ↓
Review Controller
   ↓
Review Service
   ↓
Review Repository
   ↓
Prisma / Database
-------------------code----------------------

---

## Notes on Design Decisions

* The **service layer** currently acts as a pass-through.
* This may seem unnecessary, but it:

  * Keeps architecture consistent
  * Allows future business logic without refactoring controllers
* Later in the course, this layer can be removed if proven redundant.

---

## Testing the Endpoint

### Valid Product ID

* Returns an array of reviews

### Invalid Numeric ID

* Returns an empty array

### Non-numeric Product ID

-------------------code----------------------
{
  "error": "Invalid product ID"
}
-------------------code----------------------

### Postman Cache Issue

If results do not update:

1. Switch to **Preview** tab
2. Return to **Pretty** tab

---

## Result

* Clean separation of concerns
* Modular, scalable structure
* Endpoint works exactly as before
* Code is easier to test and maintain

---

## Next Step

Implement an endpoint for **summarizing reviews**.


*** 3.3- Creating an API for Summarizing Reviews ***
---

# Creating a Reviews Summarization Endpoint

## Objective

Create a new endpoint that summarizes reviews for a given product by:

* Adding a new POST route
* Extending the controller and service layers
* Reusing the repository with a configurable limit
* Returning a placeholder summary (LLM integration will come later)

---

## REST Design Decisions

* **HTTP Method:** `POST`

  * Summarization creates new derived data.
* **Endpoint Path:** `/products/:productId/reviews/summarize`

  * Follows RESTful conventions.
* **Response Shape:** Object instead of raw string

  -------------------code----------------------
  { "summary": "..." }
  -------------------code----------------------

---

## Step 1: Update Routes Module

### File

-------------------code----------------------
routes.ts
-------------------code----------------------

### Changes

* Duplicate the reviews route
* Change method to `POST`
* Append `/summarize`
* Map to a new controller method

### Code

-------------------code----------------------
import { Router } from "express";
import { reviewController } from "./controllers/review.controller";

const router = Router();

router.get(
  "/api/products/:id/reviews",
  reviewController.getReviews
);

router.post(
  "/api/products/:id/reviews/summarize",
  reviewController.summarizeReviews
);

export default router;
-------------------code----------------------

---

## Step 2: Add Controller Method

### File

-------------------code----------------------
controllers/review.controller.ts
-------------------code----------------------

### Responsibilities

* Validate `productId`
* Call the service layer
* Return the summary in JSON format

### Code

-------------------code----------------------
import type { Request, Response } from "express";
import { reviewService } from "../services/review.service";

export const reviewController = {
  async getReviews(req: Request, res: Response) {
    const productId = Number(req.params.id);

    if (isNaN(productId)) {
      return res.status(400).json({ error: "Invalid product ID" });
    }

    const reviews = await reviewService.getReviews(productId);
    res.json(reviews);
  },

  async summarizeReviews(req: Request, res: Response) {
    const productId = Number(req.params.id);

    if (isNaN(productId)) {
      return res.status(400).json({ error: "Invalid product ID" });
    }

    const summary = await reviewService.summarizeReviews(productId);

    res.json({
      summary,
    });
  },
};
-------------------code----------------------

---

## Step 3: Extend the Review Service

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

### Design Notes

* Summarization belongs to the service layer
* Only the **latest reviews** are used
* We intentionally avoid sending all reviews to a language model

Reasons for limiting reviews:

* Prevent large context windows
* Reduce cost
* Recent reviews better reflect product quality

### Code

-------------------code----------------------
import type { Review } from "@prisma/client";
import { reviewRepository } from "../repositories/review.repository";

export const reviewService = {
  getReviews(productId: number): Promise<Review[]> {
    return reviewRepository.getReviews(productId);
  },

  async summarizeReviews(productId: number): Promise<string> {
    const reviews = await reviewRepository.getReviews(productId, 10);

    const joinedReviews = reviews.map((r) => r.content).join("\n\n");
    // later we will add it to LLM
    // for testing our api we will just send a string
    const summary = "This is a placeholder summary";

    return summary;
  },
};
-------------------code----------------------

---

## Step 4: Update the Review Repository

### Purpose

Allow fetching a limited number of recent reviews.

### File

-------------------code----------------------
repositories/review.repository.ts
-------------------code----------------------

### Changes

* Add optional `limit` parameter
* Use Prisma’s `take` option

### Code

-------------------code----------------------
import { prisma } from "../generated/prisma";
import type { Review } from "@prisma/client";

export const reviewRepository = {
  getReviews(productId: number, limit?: number): Promise<Review[]> {
    const prisma = new PrismaClient();

    return prisma.review.findMany({
      where: { productId },
      orderBy: { createdAt: "desc" },
      take: limit,
    });
  },
};

-------------------code----------------------

---

## Step 5: How Review Text Is Prepared

* Fetch the last 10 reviews
* Extract only the `content`
* Join them into a single formatted string

-------------------code----------------------
const joinedReviews = reviews
  .map((r) => r.content)
  .join("\n\n");
-------------------code----------------------

This string will later be sent to a language model for summarization.

---

## Step 6: Testing the Endpoint

### Request

* **Method:** POST
* **URL:**

  -------------------code----------------------
  http://localhost:3000/api/products/1/reviews/summarize
  -------------------code----------------------

### Response

-------------------code----------------------
{
  "summary": "This is a placeholder summary"
}
-------------------code----------------------

---

## Current State of the Feature

* Endpoint is fully wired
* Controller, service, and repository are connected
* Reviews are fetched and prepared correctly
* Summary is currently hard-coded

---

## Next Lesson

* Send the joined reviews to a language model
* Generate a real summary
* Replace the placeholder implementation

---

*** 3.4- Generating Summaries  ***

---

# Summarizing Reviews Using a Language Model

## Objective

Replace the placeholder summary with a real AI-generated summary by:

* Sending the latest reviews to a language model
* Building a prompt for summarization
* Returning the model’s output to the client

---

## Recap from Previous Lesson

Previously, we:

* Fetched the latest reviews (limited to 10)
* Combined them into a single string (`joinedReviews`)
* Returned a hardcoded placeholder summary

In this lesson, we:

* Send `joinedReviews` to a language model
* Generate a real summary
* Prepare the code for future refactoring

---

## Reusing Existing OpenAI Setup

Earlier in the course, an OpenAI client was created inside the **chat service**:

* The client was initialized with an API key
* The same client was used to generate responses

For now:

* We will **copy this setup** into the review service
* After confirming everything works, we will refactor to remove duplication

---

## Step 1: Initialize the OpenAI Client in the Review Service

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

### Add at the Top of the File

-------------------code----------------------
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});
-------------------code----------------------

---

## Step 2: Build the Prompt for Summarization

### Prompt Design Goals

* Short paragraph
* Highlight key themes
* Include both positive and negative feedback
* Deterministic output

Prompt wording is flexible and should be tested and refined over time.

---

## Step 3: Call the Language Model

### Model Configuration Choices

* **Model:** gpt-5-mini (can be changed later)
* **Temperature:** 0.2
  Ensures consistent, low-creativity summaries
* **Max Output Tokens:** 500
  More than enough for a short paragraph

---

## Final Implementation: Review Service

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

### Code

-------------------code----------------------
import type { Review } from "@prisma/client";
import { reviewRepository } from "../repositories/review.repository";
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const reviewService = {
  getReviews(productId: number): Promise<Review[]> {
    return reviewRepository.getReviews(productId);
  },

  async summarizeReviews(productId: number): Promise<string> {
    const reviews = await reviewRepository.getReviews(productId, 10);

    const joinedReviews = reviews.map((r) => r.content).join("\n\n");
    const prompt = `
      Summarize the following customer reviews into a short paragraph,
      highlighting key themes, both positive and negative:

      ${joinedReviews}
          `;
    console.log(joinedReviews);
    const response = await client.responses.create({
      model: "gpt-5-mini",
      input: prompt,
      max_output_tokens: 1000,
    });

    console.log(response);
    return response.output_text;
  },
};

-------------------code----------------------

---

## Step 4: Testing the Endpoint

### Request

* **Method:** POST
* **URL:**

  -------------------code----------------------
  http://localhost:3000/api/products/1/reviews/summarize
  -------------------code----------------------

### Result

* The request takes slightly longer due to model inference
* A real, AI-generated summary is returned

Example response:

-------------------code----------------------
{
  "summary": "Customers generally praise the product’s build quality and performance, while some mention concerns about pricing and battery life."
}
-------------------code----------------------

---

## Key Takeaways

* Review summarization is a **service-level responsibility**
* Only recent reviews are summarized to:

  * Reduce cost
  * Control context size
  * Reflect current product quality
* Prompt engineering is iterative and experimental
* Deterministic settings are preferred for summaries

---

## Next Step

Refactor the code to:

* Remove duplicated OpenAI client initialization
* Centralize AI logic into a shared module or service


PS: Based on the logs you provided, the reason `output_text` is empty is that the model **ran out of tokens while "thinking" (reasoning)** before it could generate the actual summary.

Here is the breakdown of the evidence in your log:

1.  **The Error Reason:**
    -------------------code----------------------
    [server]   status: "incomplete",
    [server]   incomplete_details: {
    [server]     reason: "max_output_tokens",
    [server]   },
    -------------------code----------------------
    The request was stopped because it hit the `max_output_tokens` limit you set.

2.  **The Token Usage:**
    -------------------code----------------------
    [server]   usage: {
    ...
    [server]     output_tokens: 64,
    [server]     output_tokens_details: {
    [server]       reasoning_tokens: 64,
    [server]     },
    ...
    [server]   },
    -------------------code----------------------
    You set the limit to `100`. The model used **64** tokens. Crucially, **all 64 of them were `reasoning_tokens`**.

    Modern "reasoning" models (like the `gpt-5-mini` or `o1`/`o3` series you appear to be using) generate hidden "thought" tokens to plan their answer before writing the visible response. The model was still in its reasoning phase when it hit the limit (or got close enough that it couldn't proceed), so it cut off before generating any visible `output_text`.

### Solution

Increase your `max_output_tokens`.

A limit of `100` is too low for reasoning models because they need budget for **both** the hidden thoughts and the final text. Try increasing it to **500** or **1000**.

**Change this:**
-------------------code----------------------
    const response = await client.responses.create({
      model: "gpt-5-mini",
      input: prompt,
      max_output_tokens: 100, // <--- Too low
    });
-------------------code----------------------

**To this:**
-------------------code----------------------
    const response = await client.responses.create({
      model: "gpt-5-mini",
      input: prompt,
      max_output_tokens: 1000, // Give it space to think and write
    });
-------------------code----------------------

*** 3.5- Refactoring- Extracting the LLM Logic ***
---

# Refactoring LLM Integration with an Abstraction Layer

## Problem Statement

Currently, the application has **multiple direct references to OpenAI**:

* One in the **review service**
* Another in the **chat service**

This creates several problems:

* If we switch to another LLM provider (Gemini, Claude, etc.), we must update many files
* OpenAI-specific APIs, arguments, and response structures are tightly coupled to services
* The codebase becomes harder to maintain and evolve

---

## Solution Overview

Introduce a **single LLM client module** that:

* Encapsulates all LLM-specific logic
* Exposes a clean, platform-agnostic interface
* Acts as the only place that knows how to talk to an LLM provider

Services will depend on **our own types**, not OpenAI’s API.

---

## Step 1: Create the LLM Client Module

### Directory Structure

-------------------code----------------------
server/
  llm/
    client.ts
-------------------code----------------------

---

## Step 2: Move OpenAI Initialization into the LLM Client

### File

-------------------code----------------------
llm/client.ts
-------------------code----------------------

### Code

-------------------code----------------------
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});
-------------------code----------------------

---

## Step 3: Define Application-Level Types

These types are **platform-agnostic** and belong to our application, not OpenAI.

### Generate Text Options

-------------------code----------------------
export type GenerateTextOptions = {
  model?: string;
  prompt: string;
  instructions?: string;
  temperature?: number;
  maxTokens?: number;
  previousResponseId?: string;
};
-------------------code----------------------

### Generate Text Result

-------------------code----------------------
export type GenerateTextResult = {
  id: string;
  text: string;
};
-------------------code----------------------

---

## Step 4: Implement the LLM Client Interface

### Public API

* A single method: `generateText`
* Hides all OpenAI-specific complexity

### Code

-------------------code----------------------
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export type GenerateTextOptions = {
  model?: string;
  prompt: string;
  instructions?: string;
  // NOTE GPT5-mini doesn`t have this attribute
  // temperature?: number;
  maxTokens?: number;
  previousResponseId?: string;
};

export type GenerateTextResult = {
  id: string;
  text: string;
};

export const llmClient = {
  async generateText(
    options: GenerateTextOptions
  ): Promise<GenerateTextResult> {
    const {
      model = "gpt-4.1",
      prompt,
      instructions,
      // temperature = 0.2,
      maxTokens = 300,
      previousResponseId,
    } = options;

    const response = await client.responses.create({
      model,
      input: prompt,
      instructions,
      // temperature,
      max_output_tokens: maxTokens,
      previous_response_id: previousResponseId,
    });

    return {
      id: response.id,
      text: response.output_text,
    };
  },
};

-------------------code----------------------

---

## Key Design Benefits

* Only this module depends on OpenAI
* Services use application-defined types
* Switching to another provider requires changes in **one file only**

---

## Step 5: Refactor the Review Service

### Before

* Direct dependency on OpenAI
* OpenAI-specific arguments

### After

* Uses `llmClient.generateText`
* Clean, minimal logic

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

### Code

-------------------code----------------------
import type { Review } from "@prisma/client";
import { llmClient } from "../llm/client";
import { reviewRepository } from "../repositories/review.repository";

export const reviewService = {
  getReviews(productId: number): Promise<Review[]> {
    return reviewRepository.getReviews(productId);
  },

  async summarizeReviews(productId: number): Promise<string> {
    const reviews = await reviewRepository.getReviews(productId, 10);

    const joinedReviews = reviews.map((r) => r.content).join("\n\n");
    const prompt = `
      Summarize the following customer reviews into a short paragraph,
      highlighting key themes, both positive and negative:

      ${joinedReviews}
          `;
    console.log(joinedReviews);
    const response = await llmClient.generateText({
      model: "gpt-5-mini",
      prompt,
      maxTokens: 1000,
    });

    console.log(response);
    return response.text;
  },
};
-------------------code----------------------

---

## Step 6: Refactor the Chat Service

### Changes

* Remove OpenAI imports and client creation
* Use `llmClient.generateText`
* Handle conversation history via `previousResponseId`
* Work with application-level response shape

### Example Update

-------------------code----------------------
import fs from "fs";
import path from "path";
import { llmClient } from "../llm/client";
import template from "../prompts/chatbot.txt";
import { conversationRepository } from "../repositories/conversation.repository";

const parkInfoPath = path.join(__dirname, "..", "prompts", "wonderworld.md");
const parkInfo = fs.readFileSync(parkInfoPath, "utf8");
const instructions = template.replace("{{parkInfo}}", parkInfo);
interface ChatResponse {
  id: string;
  message: string;
}

export const chatService = {
  async sendMessage(
    prompt: string,
    conversationId: string
  ): Promise<ChatResponse> {
    const response = await llmClient.generateText({
      model: "gpt-5-mini",
      prompt,
      instructions,
      maxTokens: 1000,
      previousResponseId:
        conversationRepository.getLastResponseId(conversationId),
    });
    console.log(response);

    conversationRepository.setLastResponseId(conversationId, response.id);
    return {
      id: response.id,
      message: response.text,
    };
  },
};
-------------------code----------------------

---

## Important Adjustment

Because chat requires both:

* The generated text
* The response ID (for conversation history)

The LLM client now returns:

-------------------code----------------------
{
  id: string;
  text: string;
}
-------------------code----------------------

This ensures:

* No service depends on OpenAI’s response structure
* Conversation state remains provider-agnostic

---

## Step 7: Verify the Refactor

### Test

* Send a POST request to summarize reviews
* Confirm the response is still correct

### Result

* The endpoint works as before
* The summary is generated successfully
* The architecture is cleaner and more flexible

---

## Final Architecture

-------------------code----------------------
Service Layer
   ↓
LLM Client (Application Interface)
   ↓
LLM Provider (OpenAI / Gemini / Claude)
-------------------code----------------------

---

## Key Takeaways

* LLM access should be centralized
* Services should never depend on vendor-specific APIs
* Application-defined types protect against future provider changes
* This refactor significantly improves maintainability

---

## Next Lesson

Extract prompts into dedicated modules to:

* Improve readability
* Enable reuse
* Make prompt iteration easier

*** 3.6- Refactoring- Extracting the Prompt ***
---

# Refactoring Prompts into Dedicated Files

## Problem Statement

Currently, the review summarization prompt is embedded directly in the service code.

While this is manageable for short prompts, it becomes problematic as prompts:

* Grow longer and more complex
* Require frequent iteration
* Need to be reused or adjusted independently from code

To improve maintainability, prompts should be **separated from application logic**.

---

## Existing Pattern

Earlier in the course:

* A `prompts` directory was introduced
* Prompts were stored as `.txt` files
* Placeholders were used for dynamic content

We will follow the same pattern for review summarization.

---

## Step 1: Create a Prompt File

### File

-------------------code----------------------
prompts/summarize-reviews.txt
-------------------code----------------------

### Content

-------------------code----------------------
Summarize the following customer reviews into a short paragraph,
highlighting key themes, both positive and negative:

{{reviews}}
-------------------code----------------------

* `{{reviews}}` is a placeholder
* Double braces match the existing prompt templating convention

---

## Step 2: Remove the Inline Prompt from the Review Service

The prompt should no longer be hardcoded in the service logic.

---

## Step 3: Import the Prompt Template

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

### Import

-------------------code----------------------
import template from "../prompts/summarize-reviews.txt";
-------------------code----------------------

---

## Step 4: Build the Prompt Using the Template

Replace the placeholder with the joined reviews.

### Code

-------------------code----------------------
const prompt = template.replace(
  "{{reviews}}",
  joinedReviews
);
-------------------code----------------------

---

## Updated Review Service (Relevant Section)

-------------------code----------------------
import type { Review } from "@prisma/client";
import { llmClient } from "../llm/client";
import { reviewRepository } from "../repositories/review.repository";
import template from "../prompts/summarize-reviews.txt";

export const reviewService = {
  getReviews(productId: number): Promise<Review[]> {
    return reviewRepository.getReviews(productId);
  },

  async summarizeReviews(productId: number): Promise<string> {
    const reviews = await reviewRepository.getReviews(productId, 10);

    const joinedReviews = reviews.map((r) => r.content).join("\n\n");
    const prompt = template.replace("{{reviews}}", joinedReviews);

    console.log(joinedReviews);
    const response = await llmClient.generateText({
      model: "gpt-5-mini",
      prompt,
      maxTokens: 1000,
    });

    console.log(response);
    return response.text;
  },
};
-------------------code----------------------

---

## Step 5: Verify the Refactor

### Test

* Send a POST request to summarize reviews

### Result

* The endpoint works as before
* The generated summary is unchanged
* Prompt logic is now cleanly separated

---

## Benefits of This Refactoring

* Prompts are easier to read and edit
* Code focuses on logic, not text
* Prompts can be versioned and reused
* Future prompt complexity is easier to manage

---

## Current State of the Architecture

-------------------code----------------------
Service Layer
   ↓
Prompt Template (File)
   ↓
LLM Client
-------------------code----------------------

---

## Next Lesson

Store the generated review summary in the database for:

* Caching
* Reuse
* Performance improvements

*** 3.7- Storing the Summary ***

---

# Caching Review Summaries in the Database

## Problem Statement

Currently, the review summary is generated **every time** the API is called.

This approach is:

* **Slow** (LLM calls take time)
* **Expensive** (each call consumes tokens)
* **Unnecessary** (summaries do not change frequently)

---

## Goal of This Lesson

* Store generated summaries in the database
* Generate the summary **once**
* Reuse the cached version on subsequent requests
* Prepare for future expiration and regeneration logic

---

## High-Level Strategy

1. Add a repository method to **store or update** a review summary
2. Use Prisma’s `upsert` to handle insert/update
3. Add expiration logic
4. Store the summary after generating it
5. Verify persistence in the database

---

## Step 1: Extend the Review Repository

### File

-------------------code----------------------
repositories/review.repository.ts
-------------------code----------------------

### Existing State

The repository currently only fetches reviews.

We will add a new method:

* `storeReviewSummary(productId: number, summary: string)`

---

## Step 2: Prepare Prisma Client for Reuse

Move the Prisma client outside of the repository object so it can be reused by multiple methods.

-------------------code----------------------
import { prisma } from "../generated/prisma";
import dayjs from "dayjs";
-------------------code----------------------

---

## Step 3: Implement `storeReviewSummary`

### Key Concepts

* Use `upsert`

  * Inserts if the record does not exist
  * Updates if it already exists
* This avoids duplicate logic
* Ideal for caching scenarios

---

### Code

-------------------code----------------------
import { PrismaClient, type Review } from "@prisma/client";
import dayjs from "dayjs";

const prisma = new PrismaClient();

export const reviewRepository = {
  getReviews(productId: number, limit?: number): Promise<Review[]> {
    return prisma.review.findMany({
      where: { productId },
      orderBy: { createdAt: "desc" },
      take: limit,
    });
  },

  async storeReviewSummary(productId: number, summary: string) {
    const now = new Date();

    const expiresAt = dayjs().add(7, "day").toDate();

    const data = {
      content: summary,
      generatedAt: now,
      expiresAt,
      productId,
    };

    return prisma.summary.upsert({
      where: {
        productId,
      },
      create: data,
      update: data,
    });
  },
};
-------------------code----------------------

---

## Notes on Expiration Logic

* Expiration is set to **7 days**
* This value is arbitrary
* In a real system, it depends on business requirements
* Future lessons will:

  * Check expiration
  * Regenerate only when necessary

---

## Step 4: Install `dayjs`

Used for date manipulation.

-------------------code----------------------bash
bun add dayjs
-------------------code----------------------

---

## Step 5: Update the Review Service

### What Changes

* After generating the summary:

  * Store it in the database
  * Then return it
* Ensure async database writes are awaited

---

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

---

### Updated Implementation

-------------------code----------------------
import type { Review } from "@prisma/client";
import { llmClient } from "../llm/client";
import { reviewRepository } from "../repositories/review.repository";
import template from "../prompts/summarize-reviews.txt";

export const reviewService = {
  getReviews(productId: number): Promise<Review[]> {
    return reviewRepository.getReviews(productId);
  },

  async summarizeReviews(productId: number): Promise<string> {
    const reviews = await reviewRepository.getReviews(productId, 10);

    const joinedReviews = reviews.map((r) => r.content).join("\n\n");
    const prompt = template.replace("{{reviews}}", joinedReviews);

    console.log(joinedReviews);
    const { text: summary } = await llmClient.generateText({
      model: "gpt-5-mini",
      prompt,
      maxTokens: 1000,
    });

    await reviewRepository.storeReviewSummary(productId, summary);

    return summary;
  },
};
-------------------code----------------------

---

## Important Bug Fix

### Issue

The summary was not being saved because:

* The repository method was async
* It was not being awaited

### Fix

-------------------code----------------------
await reviewRepository.storeReviewSummary(productId, summary);
-------------------code----------------------

Without this, the database write may never complete.

---

## Step 6: Testing the Implementation

### Initial State

* `summaries` table is empty

### Action

* Call the summarize reviews endpoint

### Result

* Summary is generated
* Record is inserted into the database

---

## Verifying Database Behavior

### First Request

* A new record is created
* `generatedAt` is set
* `expiresAt` is one week later

### Second Request

* The same record is updated
* `generatedAt` timestamp changes
* Confirms `upsert` works correctly

---

## Current Limitation

Even though summaries are stored:

* The summary is **still regenerated every time**

This is intentional for now.

---

## What Comes Next

In the next lesson, we will:

* Check if a summary already exists
* Verify whether it has expired
* Regenerate **only if necessary**
* Fully implement caching logic

---

## Key Takeaways

* LLM outputs should be cached whenever possible
* `upsert` is ideal for derived data
* Expiration enables controlled regeneration
* Async database writes must always be awaited
* This is a foundational step toward scalable, cost-efficient AI features


To check your data in the MySQL database, here are several useful commands:

## 1. **First, connect to your database:**
-------------------code----------------------
mysql -u root -p review_summarizer
-------------------code----------------------

## 2. **Basic Commands Inside MySQL:**

### **List all tables:**
-------------------code----------------------
SHOW TABLES;
-------------------code----------------------

### **View table structure:**
-------------------code----------------------
DESCRIBE table_name;
-- or
SHOW COLUMNS FROM table_name;
-------------------code----------------------

### **View all data in a table:**
-------------------code----------------------
SELECT * FROM table_name;
-------------------code----------------------

### **View limited rows:**
-------------------code----------------------
SELECT * FROM table_name LIMIT 10;
-------------------code----------------------

### **Count total rows:**
-------------------code----------------------
SELECT COUNT(*) FROM table_name;
-------------------code----------------------

## 3. **Common Examples:**

### Check what tables exist first:
-------------------code----------------------
SHOW TABLES;
-------------------code----------------------

### Then explore a specific table:
-------------------code----------------------
-- See table structure
DESCRIBE reviews;

-- See first 20 rows
SELECT * FROM reviews LIMIT 20;

-- See specific columns
SELECT id, rating, summary FROM reviews LIMIT 10;
-------------------code----------------------

## 4. **Useful Queries:**

-------------------code----------------------
-- Check distinct values in a column
SELECT DISTINCT rating FROM reviews;

-- Check data with conditions
SELECT * FROM reviews WHERE rating >= 4;

-- Order results
SELECT * FROM reviews ORDER BY created_at DESC LIMIT 10;

-- Count by category
SELECT rating, COUNT(*) as count FROM reviews GROUP BY rating;
-------------------code----------------------

## 5. **Exit MySQL:**
-------------------code----------------------
EXIT;
-- or
QUIT;
-------------------code----------------------

## Tips:
- Replace `table_name` with your actual table name (common tables might be: `reviews`, `summaries`, `users`, etc.)
- If you're not sure about table names, always start with `SHOW TABLES;`
- Use `Ctrl+C` to cancel a long-running query
- Press up/down arrows to navigate command history


we check the data if it saved:
-------------------code----------------------
mysql> SELECT * FROM summaries LIMIT 20;
+----+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+-------------------------+
| id | productId | content                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | generatedAt             | expiresAt               |
+----+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+-------------------------+
|  1 |         1 | Overall, reviewers praise the iPhone 15 Pro for strong performance (A17 Pro, smooth iOS 17, 120Hz ProMotion), a premium lightweight titanium build and improved camera system (48MP sensor, low‑light, portrait/focus control, 5x zoom) that often replaces a DSLR for casual use. Key conveniences cited are the new USB‑C port and useful features like Dynamic Island and satellite emergency connectivity. Common negatives include overheating during heavy use or charging, aggressive image processing/skewed skin tones for some shots, modest battery gains (solid but not game‑changing), limited Action Button options, and disappointment over minimal design changes, base storage size, and the high price. Overall sentiment is very positive—many are very satisfied—though several note it’s an evolutionary, not revolutionary, upgrade.             | 2026-01-08 04:49:06.857 | 2026-01-15 04:49:06.857 |
+----+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+-------------------------+
1 row in set (0.000 sec)
-------------------code----------------------


*** 3.8- Handling Regeneration ***

---

# Regenerating Review Summaries Only When Necessary

## Problem Recap

In the previous lesson:

* Review summaries were stored in the database
* However, the summary was **still regenerated on every API call**

This defeats the purpose of caching.

---

## Goal of This Lesson

Generate a review summary **only if**:

* No summary exists for the product, or
* The existing summary has **expired**

Otherwise:

* Return the cached summary immediately
* Avoid unnecessary LLM calls

---

## High-Level Flow

1. Check if a summary exists for the product
2. If it exists and is still valid:

   * Return it immediately
3. If it does not exist or is expired:

   * Generate a new summary
   * Store it in the database
   * Return it

---

## Step 1: Add a Method to Fetch an Existing Summary

### File

-------------------code----------------------
repositories/review.repository.ts
-------------------code----------------------

### New Method

-------------------code----------------------
async getReviewSummary(productId: number) {
  return prisma.summary.findUnique({
    where: {
      productId,
    },
  });
}
-------------------code----------------------

* `findUnique` is used because there is only one summary per product
* Returns a promise of the summary record or `null`

---

## Step 2: Update the Review Service Logic

### File

-------------------code----------------------
services/review.service.ts
-------------------code----------------------

### New Logic Order

1. Check for an existing summary
2. Validate expiration
3. Return cached summary if valid
4. Otherwise regenerate

---

## Updated `summarizeReviews` Implementation

-------------------code----------------------
import type { Review } from "@prisma/client";
import { llmClient } from "../llm/client";
import { reviewRepository } from "../repositories/review.repository";
import template from "../prompts/summarize-reviews.txt";

export const reviewService = {
  getReviews(productId: number): Promise<Review[]> {
    return reviewRepository.getReviews(productId);
  },

  async summarizeReviews(productId: number): Promise<string> {
    const existingSummary = await reviewRepository.getReviewSummary(productId);

    if (existingSummary && existingSummary.expiresAt > new Date()) {
      return existingSummary.content;
    }

    const reviews = await reviewRepository.getReviews(productId, 10);

    const joinedReviews = reviews.map((r) => r.content).join("\n\n");
    const prompt = template.replace("{{reviews}}", joinedReviews);

    console.log(joinedReviews);
    const { text: summary } = await llmClient.generateText({
      model: "gpt-5-mini",
      prompt,
      maxTokens: 1000,
    });

    await reviewRepository.storeReviewSummary(productId, summary);

    return summary;
  },
};
-------------------code----------------------

---

## Step 3: Testing Cached Behavior

### Case 1: Summary Exists and Is Valid

* API response is returned immediately
* No delay
* No LLM call
* Database timestamps remain unchanged

---

## Step 4: Testing Expiration and Regeneration

### Manual Expiration Test

* Manually update `expiresAt` in the database to a past timestamp

### Result

* API regenerates the summary
* New LLM call is made
* Database record is updated with:

  * New `generatedAt`
  * New `expiresAt`

---

## Observed Results

* Cached summaries return instantly
* Expired summaries trigger regeneration
* Database confirms updates via timestamps

---

## Final Summary Flow

-------------------code----------------------
API Call
   ↓
Check Existing Summary
   ↓
Is Valid?
  ├─ Yes → Return Cached Summary
  └─ No  → Generate New Summary → Store → Return
-------------------code----------------------

---

## Key Takeaways

* Caching LLM output is essential for performance and cost control
* Expiration logic prevents stale summaries
* Database-backed caching provides durability
* LLM calls should only happen when strictly necessary

---

## What’s Next

* Improve expiration strategy
* Add background regeneration
* Optimize summary length and prompt quality


*** 3.9- Handling Edge Cases ***
---

# Handling Edge Cases in Review Summary API

## Why This Lesson Matters

So far, the review summary feature works only in the **happy path**.
A production-ready API must correctly handle **invalid input and unexpected scenarios** without crashing.

This lesson focuses on identifying and fixing those edge cases.

---

## Edge Cases to Handle

1. Product ID is **not numeric**
2. Product ID is numeric but **product does not exist**
3. Product exists but has **no reviews**
4. Ensure the happy path still works after fixes

---

## Edge Case 1: Non-Numeric Product ID

### Example

-------------------code----------------------
/products/A/summarize
-------------------code----------------------

### Expected Behavior

* HTTP status: `400 Bad Request`
* Error message: `Invalid product ID`

### Status

Already handled correctly via input validation.

---

## Edge Case 2: Numeric but Invalid Product ID

### Example

-------------------code----------------------
/products/10/summarize
-------------------code----------------------

### Problem

* API returned `500 Internal Server Error`
* Server crashed because product did not exist

### Solution

Validate product existence **before** summarizing reviews.

---

## Step 1: Create Product Repository

### File

-------------------code----------------------
repositories/product.repository.ts
-------------------code----------------------

### Code

-------------------code----------------------
import { PrismaClient } from "../generated/client";

const prisma = new PrismaClient();

export const productRepository = {
  async getProduct(productId: number) {
    return prisma.product.findUnique({
      where: {
        id: productId,
      },
    });
  },
};
-------------------code----------------------

---

## Step 2: Validate Product in Controller

### File

-------------------code----------------------
controllers/review.controller.ts
-------------------code----------------------

### Updated Controller Logic

-------------------code----------------------
import type { Request, Response } from "express";
import { productRepository } from "../repositories/product.repository";
import { reviewService } from "../services/review.service";

export const reviewController = {
  async getReviews(req: Request, res: Response) {
    const productId = Number(req.params.id);

    if (isNaN(productId)) {
      return res.status(400).json({ error: "Invalid product ID" });
    }

    const reviews = await reviewService.getReviews(productId);
    res.json(reviews);
  },

  async summarizeReviews(req: Request, res: Response) {
    const productId = Number(req.params.id);

    if (isNaN(productId)) {
      return res.status(400).json({ error: "Invalid product ID" });
    }

    const product = await productRepository.getProduct(productId);

    if (!product) {
      return res.status(400).json({
        error: "Invalid product",
      });
    }

    const summary = await reviewService.summarizeReviews(productId);

    res.json({
      summary,
    });
  },
};
-------------------code----------------------

### Result

* API returns `400`
* Server no longer crashes

---

## Edge Case 3: Product Has No Reviews

### Problem

If a product has no reviews:

* LLM returns awkward responses like:

  > "It looks like you haven't provided customer reviews yet"

This is unacceptable.

---

## Design Decision

Two valid approaches:

1. Return an empty summary
2. Return an error

### Chosen Approach

Return an error because:

* Frontend should hide “Summarize” button if no reviews exist
* This situation should not happen logically

---

## Step 3: Check If Reviews Exist (Efficiently)

### Controller Update

-------------------code----------------------
const reviews = await reviewRepository.getReviews(productId, 1);

if (!reviews.length) {
  return res.status(400).json({
    error: "There are no reviews to summarize",
  });
}
-------------------code----------------------

### Why Limit = 1?

* We only need to know if **at least one review exists**
* Avoids unnecessary database load

---

## Final Controller Flow

-------------------code----------------------
1. Validate product ID is numeric
2. Validate product exists
3. Validate product has reviews
4. Call summarize service
5. Return summary
-------------------code----------------------

---

## Testing All Scenarios

### Invalid Product ID (Non-Numeric)

* Status: `400`
* Message: `Invalid product ID`

### Invalid Product ID (Numeric but Missing)

* Status: `400`
* Message: `Invalid product`

### No Reviews

* Status: `400`
* Message: `There are no reviews to summarize`

### Happy Path

* Status: `200`
* Summary generated or fetched from cache

---

## Cleaning Up Bad Data

A summary generated earlier for a product with no reviews must be removed manually from the database.

This was a **bug**, not valid data.

---

## Final Verification

* Cached summaries return instantly
* Expired summaries regenerate correctly
* No unnecessary OpenAI calls
* All execution paths tested successfully

---

## Key Takeaways

* Always think beyond the happy path
* Validate inputs early
* Prevent invalid states from reaching business logic
* Never rely on LLMs to handle missing data gracefully
* Defensive APIs are stable APIs

---

## What’s Next

* Background summary regeneration
* Better expiration strategies
* API rate limiting
* Observability and logging


*** 3.10- Fetching the Summary ***
---

# Including Review Summaries in the Reviews Endpoint

## Goal of This Lesson

Previously, we implemented:

* An endpoint to fetch reviews for a product
* A separate endpoint to fetch a review summary

In this lesson, we **improve the reviews endpoint** so it returns:

* The list of reviews
* The review summary (if it exists and is valid)

This allows the frontend to fetch everything it needs in **one request**, resulting in:

* Cleaner client-side code
* Fewer API calls
* Better performance

---

## Step 1: Remove Unnecessary Service Layer

### Problem

The current `reviewService.getReviews` method:

* Contains no business logic
* Simply forwards the call to the repository

This violates clean architecture principles.

### Solution

Remove the service and let the controller talk directly to the repository.

### Actions

* Delete `getReviews` method from `review.service.ts`
* Remove the unused `Review` type import
* Replace `reviewService` with `reviewRepository` in the controller

---

## Step 2: Fetch Reviews and Summary Together

### Controller Logic

After fetching reviews, fetch the summary and return both in a single response.

-------------------code----------------------
const reviews = await reviewRepository.getReviews(productId);
const summary = await reviewRepository.getReviewSummary(productId);

res.json({
  summary,
  reviews,
});
-------------------code----------------------

---

## Step 3: Handling Expired Summaries (Initial Idea)

A possible approach:

-------------------code----------------------
const summary =
  summaryRecord &&
  summaryRecord.expiresAt > new Date()
    ? summaryRecord.content
    : null;
-------------------code----------------------

### Problem with This Approach

* This expiration logic already exists elsewhere
* Logic is duplicated
* Every consumer must re-implement expiration checks

This indicates **incorrect responsibility placement**.

---

## Architectural Insight

When logic is duplicated across services and controllers:

* Responsibilities are misplaced
* The abstraction boundary is wrong

### Correct Responsibility

The **repository** should:

* Decide whether a summary is valid
* Hide expiration logic
* Return only what the application needs

---

## Step 4: Move Expiration Logic Into Repository

### Original Method (Problematic)

-------------------code----------------------
prisma.summary.findUnique({
  where: {
    productId,
  },
});
-------------------code----------------------

This cannot:

* Filter by expiration date
* Combine conditions

---

## Step 5: Use `findFirst` With Logical Filters

### Updated Repository Method

-------------------code----------------------
async getReviewSummary(productId: number): Promise<string | null> {
  const summary = await prisma.summary.findFirst({
    where: {
      AND: [
        { productId },
        {
          expiresAt: {
            gt: new Date(),
          },
        },
      ],
    },
  });

  return summary ? summary.content : null;
}
-------------------code----------------------

### Key Concepts Used

* `AND` logical operator
* `gt` (greater than) for date comparison
* `findFirst` instead of `findUnique`

---

## Why `findUnique` Does Not Work

* `findUnique` only supports **unique constraints**
* Cannot combine multiple conditions
* Prisma enforces this at compile time

---

## Step 6: Hide Implementation Details

### Summary Model Fields

* id
* productId
* content
* generatedAt
* expiresAt

Only **content** is relevant outside the repository.

### Best Practice

* Do not expose `expiresAt` or `generatedAt`
* Return `string | null`
* Keep expiration logic internal

---

## Step 7: Simplify Service Logic

### Before

-------------------code----------------------
if (existingSummary && existingSummary.expiresAt > new Date()) {
  return existingSummary.content;
}
-------------------code----------------------

### After

-------------------code----------------------
const summary = await reviewRepository.getReviewSummary(productId);

if (summary) {
  return summary;
}
-------------------code----------------------

Cleaner, shorter, and no duplication.

---

## Step 8: Simplify Controller Logic

### No More Expiration Checks

-------------------code----------------------
const summary = await reviewRepository.getReviewSummary(productId);

res.json({
  summary,
  reviews,
});
-------------------code----------------------

The controller does not care **how** the summary is validated.

---

## Step 9: Validate Product Existence (RESTful Fix)

### Problem

Requesting reviews for a non-existent product returned:

-------------------code----------------------
{
  "summary": null,
  "reviews": []
}
-------------------code----------------------

This is misleading.

### RESTful Solution

Return `404 Not Found` if the product does not exist.

---

## Updated Controller Logic

-------------------code----------------------
const product = await productRepository.getProduct(productId);

if (!product) {
  return res.status(404).json({
    error: "Product does not exist",
  });
}
-------------------code----------------------

---

## Final Controller Flow

-------------------code----------------------
1. Validate product ID
2. Check product existence
3. Fetch reviews
4. Fetch valid summary (if any)
5. Return { summary, reviews }
-------------------code----------------------

---

## Testing Scenarios

### Valid Product With Summary

* Summary returned
* Reviews returned

### Expired Summary

* Summary is null
* Reviews returned

### Product With No Reviews

* Summary: null
* Reviews: []

### Invalid Product ID

* Status: 404
* Error message returned

---

## Key Takeaways

* Controllers should not contain business rules
* Repositories must encapsulate filtering and validity logic
* Avoid duplicating logic across layers
* Hide implementation details behind abstractions
* Use RESTful status codes consistently
* Clean architecture leads to simpler code everywhere

---

## Result

* Single efficient endpoint
* No duplicated expiration logic
* Clean separation of concerns
* Predictable, RESTful responses
* Easier future maintenance and extension


*** 4- Building the Frontend ***
---

# Transition to Frontend Development

## Context

At this point:

* The backend is complete
* Review fetching, summarization, caching, expiration, and edge cases are all handled correctly
* The API is stable and production-ready

Now we shift focus to the **frontend**.

---

## Goal of This Phase

The objective is to build a frontend that:

* Displays product reviews
* Displays the review summary (when available)
* Uses the backend efficiently
* Remains clean, responsive, and maintainable

---

## Key Frontend Responsibilities

The frontend will:

* Call the improved reviews endpoint
* Render:

  * The list of reviews
  * The review summary (if returned)
* Handle error states gracefully:

  * Invalid product
  * No reviews available
* Avoid unnecessary API calls

Because the backend now returns **reviews and summary in a single request**, the frontend logic becomes simpler and more efficient.

---

## Design Principles

During frontend development, we will focus on:

* Clean UI layout
* Clear separation of concerns
* Reusable components
* Minimal duplication
* Readable and maintainable code

---

## Planned Refactoring

Once the UI is functional:

* We will refactor frontend code
* Improve structure and naming
* Extract reusable components
* Simplify state and data flow

This mirrors what we did on the backend:

* First make it work
* Then make it clean

---

## High-Level Flow

1. Call backend reviews endpoint
2. Receive:

   * Reviews
   * Optional summary
3. Render UI accordingly
4. Refactor for clarity and scalability

---

## Key Takeaway

With a well-designed backend:

* Frontend development becomes straightforward
* Fewer API calls are needed
* UI logic stays simple
* Refactoring is easier and safer

This lesson marks the transition from **backend architecture** to **user-facing experience**.

*** 4.1- Displaying Reviews ***

---

# Connecting the Frontend to the Backend (Fetching Reviews)

## Objective

In this lesson, we connect the frontend to the backend and fetch product reviews from the API.
We build the first review-related React component step by step and render real data from the server.

---

## Component Organization

To keep the frontend code organized:

* Navigate to:
  `client/src/components`
* Create a new directory called:
  **reviews**

This directory will contain all components related to rendering reviews.

---

## ReviewList Component

### File Creation

* Inside the `reviews` directory, create:

  * `ReviewList.tsx`
* Use the `rafce` snippet to generate a React Arrow Function Component.

---

## Props Definition

The component needs to know **which product** to fetch reviews for.

-------------------code----------------------
type ReviewListProps = {
  productId: number;
};
-------------------code----------------------

* Destructure `productId` from props inside the component.

---

## Review Type Definition

To type our state correctly, we define a `Review` type based on the API response and Prisma schema.

-------------------code----------------------
type Review = {
  id: number;
  author: string;
  content: string;
  rating: number;
  createdAt: string;
};
-------------------code----------------------

Note:

* `createdAt` is a Date in the backend but is serialized as a string in JSON.

---

## API Response Type

The reviews endpoint returns an object with **two properties**:

* `summary`: string or null
* `reviews`: array of reviews

-------------------code----------------------
type GetReviewsResponse = {
  summary: string | null;
  reviews: Review[];
};
-------------------code----------------------

---

## State Management

We store the entire API response in state:

-------------------code----------------------
const [reviewData, setReviewData] = useState<GetReviewsResponse | null>(null);
-------------------code----------------------

---

## Fetching Reviews with useEffect

### API Call Logic

* Use `axios` to fetch data
* The endpoint format:

-------------------code----------------------
/api/products/{productId}/reviews
-------------------code----------------------

Example implementation:

-------------------code----------------------
const fetchReviews = async () => {
  const { data } = await axios.get<GetReviewsResponse>(
    `/api/products/${productId}/reviews`
  );
  setReviewData(data);
};
-------------------code----------------------

---

### useEffect Hook

Call `fetchReviews` inside `useEffect`.

Important:

* Always include a dependency array to avoid infinite requests.

-------------------code----------------------
useEffect(() => {
  fetchReviews();
}, [productId]);
-------------------code----------------------

---

## Rendering Reviews

Once data is fetched:

* Map over `reviewData.reviews`
* Render each review inside a `div`
* Use `review.id` as the key

### Rendered Fields

For each review:

* Author
* Rating (out of 5)
* Content

Example structure:

-------------------code----------------------
<div key={review.id}>
  <div>{review.author}</div>
  <div>{review.rating} / 5</div>
  <p>{review.content}</p>
</div>
-------------------code----------------------

---

## Integrating ReviewList into App

In `App.tsx`:

* Remove the chatbot component
* Render the review list instead

-------------------code----------------------
<ReviewList productId={1} />
-------------------code----------------------

---

## Styling Improvements

Basic styling using utility classes:

* Parent container:

  * Flex
  * Column layout
  * Vertical spacing

-------------------code----------------------
<div className="flex flex-col gap-5">
-------------------code----------------------

* Author:

  * Semi-bold font

-------------------code----------------------
<div className="font-semibold">
-------------------code----------------------

* Review content:

  * Vertical padding

-------------------code----------------------
<p className="py-2">
-------------------code----------------------

---

## Result

* Reviews are fetched from the backend successfully
* No errors in the browser
* UI displays real data
* Styling is clean and readable

---

## Key Takeaways

* Group related components into feature-based directories
* Always define frontend types based on API responses
* Use `useEffect` dependency arrays correctly
* Build UI incrementally: functionality first, styling later

---

## Next Step

Now that reviews are rendering correctly, the next lesson will build on this foundation and further improve the frontend.


final file 
-------------------code----------------------
import { useEffect, useState } from "react";
import axios from "axios";

type ReviewListProps = {
  productId: number;
};

type Review = {
  id: number;
  author: string;
  content: string;
  rating: number;
  createdAt: string;
};

type GetReviewsResponse = {
  summary: string | null;
  reviews: Review[];
};

const ReviewList = ({ productId }: ReviewListProps) => {
  const [reviewData, setReviewData] = useState<GetReviewsResponse | null>(null);

  const fetchReviews = async () => {
    const { data } = await axios.get<GetReviewsResponse>(
      `/api/products/${productId}/reviews`
    );
    setReviewData(data);
  };

  useEffect(() => {
    fetchReviews();
  }, [productId]);

  if (!reviewData) {
    return <div>Loading reviews...</div>;
  }

  return (
    <div className="flex flex-col gap-5">
      {reviewData.reviews.map((review) => (
        <div key={review.id} className="border rounded p-4">
          <div className="font-semibold">{review.author}</div>
          <div className="text-sm text-gray-600">
            Rating: {review.rating} / 5
          </div>
          <p className="py-2">{review.content}</p>
        </div>
      ))}
    </div>
  );
};

export default ReviewList;
-------------------code----------------------