*** 1- Introduction ***
---

## Lecture Overview: Product Review Summarizer Project

### 1. Project Introduction

* This section introduces a more advanced and engaging project.
* The goal is to build a **product review summarizer**.
* Users can generate a concise summary instead of reading all individual reviews.

### 2. User Experience Flow

* A product page displays:

  * A list of user reviews for a product.
  * A button to summarize the reviews.
* When the user clicks the **Summarize Reviews** button:

  * A summary is generated automatically.
  * The summary helps users quickly understand overall feedback.

### 3. Summary Persistence

* Once the summary is generated:

  * It is stored in the database.
  * When the user revisits the page, the summary is retrieved from the database.
  * The summary does **not** need to be regenerated each time.
* This improves:

  * Performance
  * Cost efficiency
  * User experience

### 4. Common Industry Pattern

* This “generate once, reuse later” pattern is increasingly common in modern applications.
* Especially relevant for:

  * AI-powered features
  * Content summarization
  * Recommendation systems

### 5. Project Complexity

* This project is more complex than the previous chatbot project.
* It is a **full-stack application**, involving:

  * Frontend (user interface)
  * Backend (business logic)
  * Database (data storage)

### 6. Database Introduction

* The project uses a database to store summaries.
* Prior database knowledge is **not required**.
* The instructor will cover:

  * Essential database concepts
  * Only what is necessary for this project

### 7. Learning Mindset

* The project is meant to be built step by step.
* Learners are encouraged to:

  * Take their time
  * Follow along carefully
  * Treat this as a hands-on learning experience

---


*** 2- Setting Up the Database ***
---

## Lecture Overview: Database Setup for the Project

### 1. Project Complexity

* This project is more complex than the previously built chatbot project.
* It is a **full-stack application**.
* The application includes its **own database**, which is a core component of the system.

### 2. Purpose of This Segment

* The focus of this segment is on **setting up the database from scratch**.
* The database will serve as the foundation for the rest of the application.

### 3. Database Initialization

* The database will be:

  * Created from the ground up
  * Properly structured to support application features

### 4. Populating the Database

* The database will be filled with **realistic sample data**.
* This ensures:

  * Meaningful testing
  * More realistic development scenarios
  * Better understanding of how the application behaves with real data

### 5. Role of the Database in Development

* Having realistic data allows developers to:

  * Build features more effectively
  * Test logic and edge cases
  * Develop and debug the application with confidence

### 6. Next Steps

* With the database in place and populated:

  * The rest of the application can be built on top of it
  * Backend and frontend features can be developed incrementally

---


*** 2.1- Setting Up MySQL ***
---

## Lecture Overview: Database Setup with MySQL

### 1. Purpose of This Step

* Before building the API, a database must be set up.
* The database will store:

  * Products
  * Reviews
  * Generated summaries
* This database is a foundational part of the application.

### 2. Database Technology Choice

* The project uses **MySQL**.
* MySQL is:

  * Open source
  * A relational database system
  * Widely used in real-world production applications

### 3. Installation Options

* If MySQL is already installed locally:

  * You can continue using the existing installation.
* If MySQL is not installed:

  * Download and install it from the official website.

### 4. Downloading MySQL

* Open a browser and go to **mysql.com**.
* Navigate to the **Downloads** section.
* Scroll to the bottom and select **MySQL Community Downloads**.
* Click on **MySQL Community Server**.
* Choose the latest version for your operating system.

#### Mac-Specific Notes

* Select the correct package based on CPU architecture:

  * ARM (Apple Silicon)
  * x86 (Intel CPUs)
* On the download page:

  * No login or signup is required.
  * Click **“No thanks, just start my download”**.

### 5. Installing MySQL

* Open the installer once the download completes.
* Follow the installation steps:

  * Click **Continue**
  * Agree to the license terms
  * Proceed with installation
* When prompted:

  * Enter your computer’s login password.
* Set a password for the **root (admin) MySQL user**.

  * This password is important and will be used later in the application.
  * Make sure to remember it.
* Complete the installation.
* Enter your computer password again if requested.
* After installation, the installer file can be moved to trash.

### 6. Verifying the Installation

* Open a terminal window.
* Run the following command:
-------------------code----------------------
mysql -u root -p
-------------------code----------------------

* Press Enter.
* When prompted:

  * Enter the MySQL root password you created during installation.
* If the MySQL shell opens successfully:

  * MySQL is installed correctly.

### 7. Exiting the MySQL Shell

* To exit the MySQL shell:

  * Type `quit`
  * Press Enter

### 8. Next Step

* With MySQL installed and verified:

  * The next step is to set up **Prisma**
  * Prisma will be used to interact with the database from the application

---

*** 2.2- Setting Up Prisma ***
---

## Lecture Overview: Connecting MySQL to the Application Using Prisma

### 1. Goal of This Lesson

* Now that MySQL is running, the next step is to connect the application to the database.
* This connection will be handled using **Prisma**.

---

## 2. What Is Prisma?

* Prisma is an **ORM (Object Relational Mapping) tool**.
* It sits between:

  * The application code
  * The database
* Prisma acts like a translator:

  * Converts application code into database queries
  * Provides a clean and type-safe way to interact with the database

---

## 3. Preparing the Project

* Open a terminal window.
* Navigate to the **server directory** of the project.
* Two Prisma-related packages need to be installed:

  * One for development
  * One for runtime usage

---

## 4. Installing Prisma Dependencies

### 4.1 Install Prisma CLI (Development Dependency)

* Run the following command:
-------------------code----------------------
bun add -d prisma
-------------------code----------------------
* Purpose:

  * Provides a command-line interface
  * Used to create and manage the database schema

### 4.2 Install Prisma Client (Runtime Dependency)

* Run:
-------------------code----------------------
bun add @prisma/client
-------------------code----------------------
* Purpose:

  * Allows the application code to communicate with the database

---

## 5. Initializing Prisma

* Run the following command in the server directory:

-------------------code----------------------
bunx prisma init
-------------------code----------------------
* This initializes Prisma for the project.

### Result of Initialization

* A new directory named **prisma** is created.
* Inside it, a **schema file** is generated.

---

## 6. Understanding the Prisma Schema File

* The schema file contains two main sections:

  1. **Client definition**

     * Specifies how Prisma generates the client
  2. **Database definition**

     * Specifies which database is being used and how to connect to it

---

## 7. Configuring Prisma for MySQL

### 7.1 Change Database Provider

* The default provider is set to PostgreSQL.
* Change the provider to **MySQL**.

### 7.2 Database Connection URL

* Prisma uses an environment variable named:

  * `DATABASE_URL`
* Copy this key name.

---

## 8. Updating the Environment File

* Open the `.env` file.
* Prisma may add incorrect or duplicated lines due to a known issue.
* Delete the incorrect lines.
* Paste and define the correct `DATABASE_URL`.

---

## 9. MySQL Connection String Format

-------------------code----------------------
DATABASE_URL="mysql://username:password@host:port/database_name"
-------------------code----------------------

### Example Used in This Project

* Username: `root`
* Password: the password set during MySQL installation
* Host: `localhost`
* Port: `3306` (default MySQL port)
* Database name: `review_summarizer`

### Final Example

-------------------code----------------------
DATABASE_URL="mysql://root:your_password@localhost:3306/review_summarizer"
-------------------code----------------------

### What This Does

* Connects Prisma to:

  * The local MySQL server
  * Using the root user
  * Targeting the specified database

---

## 10. Lesson Summary

* Prisma is successfully installed and initialized.
* The application is now connected to MySQL.
* The database connection is configured using environment variables.

---

## 11. Next Lesson

* Define the **structure of the database**:

  * Tables
  * Relationships
  * Fields
* This will be done using the Prisma schema.

---


*** 2.3- Defining the Prisma Schema ***
---

## Lecture Overview: Defining the Prisma Schema

### 1. Purpose of the Prisma Schema

* The Prisma schema defines the **structure of the database** directly in the codebase.
* It specifies:

  * Tables (models)
  * Fields (columns)
  * Data types
  * Relationships between tables

---

## 2. Installing the Prisma VS Code Extension

* Before editing the schema, install the **Prisma extension**.
* Steps:

  * Open the Extensions panel in the editor
  * Search for **Prisma**
  * Install the extension
* Benefits:

  * Syntax highlighting
  * Automatic formatting
  * Autocompletion
  * Improved developer experience

---

## 3. Opening the Schema File

* Open `schema.prisma` in the `prisma` directory.
* This file is where all database models will be defined.

---

## 4. Models to Be Defined

* Three models will be created:

  1. `Product`
  2. `Review`
  3. `Summary`
* Models use **PascalCase naming convention** (first letter uppercase).

---

## 5. Defining the Product Model

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id` (primary key)
    * `@default(autoincrement())`
* `name`

  * Type: `String`
* `description`

  * Type: `String?` (optional)
* `price`

  * Type: `Float`
* `reviews`

  * Type: `Review[]` (one-to-many relationship)
* `summary`

  * Type: `Summary?` (optional one-to-one relationship)

### Notes

* The `id` field uniquely identifies each product.
* Auto-increment allows the database to assign IDs automatically.

---

## 6. Defining the Review Model

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id`
    * `@default(autoincrement())`
* `author`

  * Type: `String`
* `rating`

  * Type: `Int`
* `content`

  * Type: `String`
* `createdAt`

  * Type: `DateTime`
  * Attribute:

    * `@default(now())`
* `productId`

  * Type: `Int`
* `product`

  * Type: `Product`
  * Attribute:

    * `@relation(fields: [productId], references: [id])`

### Relationship Explanation

* Each review belongs to a single product.
* The `productId` field references the `id` field in the `Product` model.
* This creates a **one-to-many relationship**:

  * One product → many reviews

---

## 7. Defining the Summary Model

### Purpose

* Stores AI-generated summaries for products.
* Each summary belongs to exactly one product.

### Fields

* `id`

  * Type: `Int`
  * Attributes:

    * `@id`
    * `@default(autoincrement())`
* `productId`

  * Type: `Int`
  * Attribute:

    * `@unique`
* `product`

  * Type: `Product`
  * Attribute:

    * `@relation(fields: [productId], references: [id])`
* `content`

  * Type: `String`
* `generatedAt`

  * Type: `DateTime`
  * Attribute:

    * `@default(now())`
* `expiresAt`

  * Type: `DateTime`

### Relationship Explanation

* This is a **one-to-one relationship**:

  * One product → one summary
* The `@unique` attribute on `productId` is required to enforce one-to-one behavior.
* The `summary` field in the `Product` model is optional because:

  * A product may not yet have reviews or a summary.

---

## 8. Common Schema Errors and Fixes

### Missing Opposite Relationship

* Prisma requires relationships to be defined on both models.
* Fix by adding:

  * `reviews` and `summary` fields to the `Product` model

### One-to-One Relation Error

* Error: one-to-one relations require unique fields.
* Fix:

  * Add `@unique` to `productId` in the `Summary` model

---

## 9. Formatting the Schema

* Save the file to auto-format.
* If formatting does not work:

  * Open the command palette
  * Select **Format Document**
  * Choose **Prisma** as the formatter

---

## 10. Lesson Summary

* Database structure is now fully defined using Prisma.
* Models, fields, and relationships are clearly specified.
* The schema is ready to be used to generate database tables.

---

## 11. Next Lesson

* Use the Prisma schema to **generate actual database tables**.
* Apply the schema to the MySQL database.

---
-------------------code----------------------
model Product {
  id          Int       @id @default(autoincrement())
  name        String
  description String?
  price       Float

  reviews     Review[]
  summary     Summary?
}

model Review {
  id        Int      @id @default(autoincrement())
  author    String
  rating    Int
  content   String
  createdAt DateTime @default(now())

  productId Int
  product   Product  @relation(fields: [productId], references: [id])
}

model Summary {
  id          Int      @id @default(autoincrement())
  productId   Int      @unique
  product     Product  @relation(fields: [productId], references: [id])
  content     String
  generatedAt DateTime @default(now())
  expiresAt   DateTime
}
-------------------code----------------------

*** 2.4- Running Migrations ***

---

## Creating Database Tables with Prisma Migrations

### 1. Purpose of Migrations

* After defining the **Prisma schema**, the next step is to create the actual database tables.
* This is done using **Prisma migrations**, which:

  * Create or update database tables.
  * Keep the database schema in sync with the codebase.
* Think of migrations like **Git commits**, but for database changes.

---

### 2. Creating the First Migration

#### Steps:

1. Open a terminal pointing to the **server directory**.
2. Run the Prisma CLI migration command:

-------------------code----------------------
bunx prisma migrate dev
-------------------code----------------------

3. Prisma automatically:

   * Creates the database if it does not exist.
   * Detects the schema.
   * Prompts for a migration name.

4. Since this is the first migration, name it:

-------------------code----------------------
init
-------------------code----------------------

#### Best Practice:

* Every time you modify `schema.prisma`, create a **new migration**.
* Use clear, descriptive migration names.

---

### 3. Migration Files Structure

* A new directory is created:

-------------------code----------------------
prisma/
 └── migrations/
     └── 2025xxxxxx_init/
         └── migration.sql
-------------------code----------------------

#### Contents:

* Each migration folder contains:

  * A **timestamp**
  * The **migration name**
  * A `migration.sql` file

#### migration.sql:

* Contains raw SQL instructions.
* In this case:

  * `CREATE TABLE product`
  * `CREATE TABLE review`
  * `CREATE TABLE summary`
* These SQL statements are generated directly from the Prisma models.

---

### 4. Inspecting the Database Using DataGrip

#### Why DataGrip:

* A visual database client by JetBrains.
* Allows you to:

  * Browse tables
  * View data
  * Run SQL queries

#### Notes:

* Commercial software, but:

  * Free trial is available.
* Not affiliated with JetBrains.

#### Download:

* Visit: `jetbrains.com/datagrip`

---

### 5. Connecting DataGrip to MySQL

#### Setup Steps:

1. Open DataGrip and create a new project.
2. Click **+ → Data Source → MySQL**.
3. Enter connection details:

   * Host: `localhost`
   * Port: `3306`
   * User: `root`
   * Password: your MySQL password

#### First-Time Setup:

* You may see a warning about missing MySQL drivers.
* Click the provided link to download them.
* Click **Test Connection** to verify.

---

### 6. Viewing the Database and Tables

* Select the application database (e.g., `review_summarizer`).
* You will see:

  * System databases (used internally by MySQL)
  * Your application database

#### Tables inside the database:

1. `prisma_migrations`
2. `product`
3. `review`
4. `summary`

---

### 7. The prisma_migrations Table

* Used internally by Prisma.
* Tracks:

  * Migration name
  * Timestamp
  * Checksum (for validation)

#### Important:

* **Never modify this table manually**.
* Prisma uses the checksum to detect changes.
* Editing migration files after running them will cause Prisma to fail.

---

### 8. Product Table Structure

#### Columns:

* `id`
* `name`
* `description`
* `price`

#### Column Types:

* `name` is defined as:

-------------------code----------------------
VARCHAR(191)
-------------------code----------------------

#### Explanation:

* `VARCHAR` means variable-length string.
* `191` is Prisma’s default for MySQL.
* This value differs depending on the database engine:

  * MySQL
  * PostgreSQL
  * Others

---

### 9. Naming Conventions in Databases

* Common database practices:

  * Use lowercase table names
  * Use plural names (e.g., `products` instead of `product`)
* Prisma defaults to model-based naming.
* Customization is possible and will be covered later.

---

### 10. Upcoming Improvements

* In modern applications:

  * `VARCHAR(255)` is often preferred over `VARCHAR(191)`.
* In the next lesson:

  * The schema will be customized.
  * A new migration will be created to apply these changes.

---

### Key Takeaways

* Prisma migrations bridge schema definitions and real database tables.
* Each schema change requires a new migration.
* Prisma generates raw SQL automatically.
* Database clients like DataGrip help visualize and verify changes.
* Internal Prisma tables should never be edited manually.

---


Errors:
bunx prisma migrate dev
-------------------code----------------------
Loaded Prisma config from prisma.config.ts.

Prisma schema loaded from prisma/schema.prisma.
Datasource "db": MySQL database "review_summarizer" at "localhost:3306"

Error: P1000: Authentication failed against database server, the provided database credentials for `root` are not valid.

Please make sure to provide valid database credentials for the database server at the configured address.
-------------------code----------------------

- first check the sql uf running
-------------------code----------------------
$ brew services list
Name              Status  User            File
mongodb-community started mahmouddabbbagh ~/Library/LaunchAgents/homebrew.mxcl.mongodb-community.plist
mysql             none
php               none
postgresql@14     started mahmouddabbbagh ~/Library/LaunchAgents/homebrew.mxcl.postgresql@14.plist
unbound           none
-------------------code----------------------

- to run it 
-------------------code----------------------
$ brew services start mysql
==> Successfully started `mysql` (label: homebrew.mxcl.mysql)
-------------------code----------------------

- check the connection by Connect to MySQL to check root password
-------------------code----------------------
$ mysql -u root

# If you set a password before
$ mysql -u root -p
-------------------code----------------------

- to change the password
1- Connect to MySQL
-------------------code----------------------
mysql -u root -p
-------------------code----------------------

2- Once connected in MySQL shell:
-------------------code----------------------
ALTER USER 'root'@'localhost' IDENTIFIED BY 'your_new_password_here';
FLUSH PRIVILEGES;
exit;
-------------------code----------------------

*** 2.5- Refining the Prisma Schema ***
---

## Refining the Prisma Schema (Best Practices)

### 1. Purpose of This Cleanup

* The goal of this lesson is to **refine and clean up the Prisma schema**.
* These changes are **not required** for the application to function.
* They reflect **real-world database best practices** and improve:

  * Readability
  * Maintainability
  * Long-term scalability

---

### 2. Renaming Database Tables

#### Problem:

* Prisma uses **PascalCase** model names by default.
* Many developers prefer:

  * Lowercase table names
  * Pluralized names

#### Solution: `@@map`

* Prisma allows overriding table names using the `@@map` attribute.

#### Example:

-------------------code----------------------
model Product {
  ...
  @@map("products")
}
-------------------code----------------------

#### Applied Changes:

* `Product` → `products`
* `Review` → `reviews`
* `Summary` → `summaries`

---

### 3. Improving String Data Types

#### Default Behavior:

* Prisma maps `String` to:

-------------------code----------------------
VARCHAR(191)
-------------------code----------------------

* This is a MySQL-specific default.

#### Best Practice:

* Use more standardized lengths for strings.
* Customize column types using the `@db` attribute.

---

### 4. Updated Data Types by Model

#### Product Model

* `name`

  * Changed to `VARCHAR(255)`
* `description`

  * Changed to `TEXT` or alternatively `VARCHAR(1000)`
  * `TEXT` chosen for greater flexibility

-------------------code----------------------
name        String @db.VarChar(255)
description String @db.Text
-------------------code----------------------

---

#### Review Model

* `author`

  * Changed to `VARCHAR(255)`
* `rating`

  * Changed from `Int` to `TINYINT`
  * Reason:

    * Ratings only range from 1 to 5
    * `Int` is unnecessarily large (up to 2 billion)

-------------------code----------------------
author String @db.VarChar(255)
rating Int    @db.TinyInt
content String @db.Text
-------------------code----------------------

---

#### Summary Model

* `content`

  * Changed to `TEXT`

-------------------code----------------------
content String @db.Text
-------------------code----------------------

---

### 5. Applying the Changes

#### Steps:

1. Save the updated `schema.prisma`
2. Prisma automatically reformats the file
3. Create a new migration:

-------------------code----------------------
npx prisma migrate dev
-------------------code----------------------

4. When prompted, name the migration:

-------------------code----------------------
refine-schema
-------------------code----------------------

---

### 6. Migration Results

#### Migration Folder:

* A new directory appears under:

-------------------code----------------------
prisma/migrations/
-------------------code----------------------

* It contains:

  * Timestamp
  * Migration name (`refine-schema`)
  * SQL file with table update instructions

---

### 7. Verifying Changes in the Database

#### In DataGrip:

* Refresh the database view
* Confirm:

  * Table names are now lowercase and plural
  * Column types are updated:

    * `name` → `VARCHAR(255)`
    * `description` → `TEXT`

#### prisma_migrations Table:

* Shows the second migration as applied
* Confirms schema changes were successfully executed

---

### 8. Key Takeaways

* Prisma allows full control over:

  * Table names
  * Column types
* Using `@@map` and `@db` improves database design quality
* Small refinements early prevent technical debt later
* Every schema change must be followed by a migration

---

### 9. Next Lesson Preview

* The next lesson will focus on **populating the database with sample data**.

---
