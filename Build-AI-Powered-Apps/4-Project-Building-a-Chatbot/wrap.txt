*** 1- Introduction ***
---

## Lecture Notes: Introduction to Building a Chatbot UI

### 1. Overview

Chatbots have become a common and essential component of modern applications. This section introduces how to build a chatbot interface from scratch.

### 2. Initial Impression vs. Reality

* At first glance, a chatbot interface seems simple.

  * A text input box
  * A send button
  * A list of messages
* However, the underlying implementation is more complex than it appears.

### 3. Hidden Complexity

Building a chatbot requires careful handling of:

* Subtle user experience details
* State management
* Various edge cases that are easy to miss without prior experience

### 4. Purpose of the Section

This part of the course will guide you step-by-step through building a functional chatbot UI while understanding the architecture and challenges involved.

---

*** 2- Building the Backend ***
---

## Lecture Notes: Chatbot Backend Development (Segment 1)

### 1. Section Structure

This part of the course is longer than usual, so it has been divided into two segments. The current segment focuses entirely on building the backend for the chatbot.

### 2. Goal of This Segment

By the end of this segment, you will have a fully functional, production-ready backend that can be connected to the frontend.

### 3. Step-by-Step Process

#### a. Building the Basic API

* Start by creating a simple API endpoint.
* The API will:

  * Receive a message sent by the user.
  * Send the message to an AI model.
  * Return the generated response.

#### b. Improving the Backend

After the basic version works, the next steps are:

* Add input validation.
* Add proper error handling.
* Ensure the system is robust, predictable, and clean.

#### c. Code Organization

* Reorganize the backend structure to keep the code modular.
* Make the project easy to maintain and scale.

---

*** 2.1- Building the Chat API ***
---

## Lecture Notes: Building a Basic Chatbot API Endpoint

### 1. Objective of the Lesson

The goal of this lesson is to build a simple API endpoint that:

* Receives a message from the user.
* Sends it to an AI model.
* Returns the generated response.

---

## 2. Initial Setup

### a. Navigate to the Server Package

* Open a new terminal window.
* Go to `packages/server`.

### b. Install OpenAI

-------------------code----------------------
bun add openai
-------------------code----------------------

### c. Import and Configure OpenAI in `index.ts`

1. Import OpenAI:

   -------------------code----------------------
   import OpenAI from "openai";
   -------------------code----------------------
2. Run environment configuration:

   -------------------code----------------------
   dotenv.config();
   -------------------code----------------------
3. Create an OpenAI client:

   -------------------code----------------------
   const client = new OpenAI({
     apiKey: process.env.OPENAI_API_KEY,
   });
   -------------------code----------------------

---

## 3. Creating the Chat Endpoint

### a. Define the POST Route

Use `app.post` because the client sends data (the prompt) to the server.

-------------------code----------------------
app.post("/api/chat", async (req: Request, res: Response) => {
  ...
});
-------------------code----------------------

### b. Extract the Prompt from the Request Body

* The request body contains a `prompt` property.
* Use destructuring for cleaner code:

-------------------code----------------------
const { prompt } = req.body;
-------------------code----------------------

---

## 4. Sending the Prompt to OpenAI

### a. Choosing the Model

The lesson compares two cost-optimized models:

* **o4-mini**
* **gpt-40-mini**

Key points:

* o4-mini is extremely fast and multimodal.
* It is significantly cheaper (about 10× cheaper per million tokens).
* Context window: 128K tokens, which is sufficient for typical chatbot interactions.
* For customer support or simple chat tasks, a cost-optimized model is appropriate.

### b. Model Selection

Use:

-------------------code----------------------
gpt-40-mini
-------------------code----------------------

### c. Creating the Response Request

-------------------code----------------------
const response = await client.responses.create({
  model: "gpt-40-mini",
  input: prompt,
  temperature: 0.2,
  max_output_tokens: 100,
});
-------------------code----------------------

Notes:

* Low temperature ensures consistency and accuracy.
* `max_output_tokens` keeps responses concise.

---

## 5. Returning the Response to the Client

After receiving the response from OpenAI:

-------------------code----------------------
return res.json({
  message: response.output_text,
});
-------------------code----------------------

- the full code:
-------------------code----------------------
app.post("/api/chat", async (req: Request, res: Response) => {
  const { prompt } = req.body;

  const response = await client.responses.create({
    model: "gpt-40-mini",
    input: prompt,
    temperature: 0.2,
    max_output_tokens: 100,
  });

  res.json({
    message: response.output_text,
  });
});
-------------------code----------------------

---

## 6. Enabling JSON Parsing in Express

### Why It Is Necessary

`req.body` will be undefined unless Express is told to parse JSON.

### Add the JSON Middleware at the Top

-------------------code----------------------
app.use(express.json());
-------------------code----------------------

This middleware:

* Runs before the route handler.
* Parses incoming JSON payloads.
* Stores them in `req.body`.

---

## 7. Summary of the Endpoint Flow

1. User sends POST request with `{ prompt: "..." }`.
2. JSON middleware parses the body.
3. The `/api/chat` route extracts the prompt.
4. The server forwards the prompt to OpenAI.
5. OpenAI returns a response.
6. The server sends the result back as JSON.

---

## 8. Next Step

The next part of the lesson will cover how to test this endpoint.

---

*** 2.2- Testing the API ***
---

## Lecture Notes: Testing the Chatbot API Endpoint

### 1. Installing the Postman Extension

* Open the extensions panel in your editor.
* Search for **Postman**.
* Install the Postman extension.
* Note: Postman is also available as a standalone application, but the extension is often more convenient.

### 2. Opening Postman in VS Code

* Open the command palette:

  * macOS: Shift + Command + P
  * Windows: Shift + Control + P
* Search for **Show Postman** and open it.
* The first time you open it, you must create an account and sign in.

  * This allows you to save requests and sync them across devices.
  * You can also share requests with team members.

### 3. Creating a New HTTP Request

* Create a new request inside Postman.
* Select **POST** as the method.
* Set the URL to:

  -------------------code----------------------
  http://localhost:3000/api/chat
  -------------------code----------------------

### 4. Setting Up the Request Body

* Open the **Body** tab.
* Choose **raw**.
* Select **JSON** from the dropdown.
* Add the JSON object you want to send:

-------------------code----------------------
{
  "prompt": "What is the capital of France?"
}
-------------------code----------------------

### 5. Sending the Request

* Click **Send**.
* You should receive a response with:

  * Status code: **200**
  * JSON output containing a message.

Example response:

-------------------code----------------------
{
  "message": "The capital of France is Paris."
}
-------------------code----------------------

### 6. Viewing the Request and Response

* You can toggle Postman’s view mode to place the request and response side by side.
* This makes it easier to observe both the input and the server output simultaneously.

### 7. Conclusion

Your API endpoint is working correctly. You have confirmed that:

* The server receives the user prompt.
* The backend sends it to the AI model.
* The model returns a valid response.
* The API sends the response back as expected.

Next lesson will continue building on this foundation.


### 8.1 the gpt module is not exist that why we use GPT5 
-------------------code----------------------
const response = await client.responses.create({
    model: "gpt-5-mini",
    input: prompt,
    // NOTE: this is not support with GPT 5
    // temperature: 0.2,
    max_output_tokens: 100,
  });
-------------------code----------------------
---

*** 2.3- Managing Conversation State ***
---

# Building Conversation Memory in a Chatbot

### Using a Global Variable, Then a Map, to Track Response History

## 1. Problem: No Conversation Memory

Currently, the chat pod does not remember previous questions.
If you ask a follow-up question like *“What was my previous question?”*, the model responds that it cannot access past interactions.

## 2. Temporary Solution: Using a Global Variable

To introduce basic memory, we create a global variable outside the route handler.

### Example

* Declare a global variable:

  -------------------code----------------------
  let lastResponseId: string | null = null;
  -------------------code----------------------
* After receiving a response from OpenAI:

  -------------------code----------------------
  lastResponseId = response.id;
  -------------------code----------------------
* When calling the `create` method, include:

  -------------------code----------------------
  previous_response_id: lastResponseId
  -------------------code----------------------

### Result

* Ask: *What is the capital of France?*
* Then ask: *What was my previous question?*
  The chatbot correctly remembers the previous question.

### Limitation

A single global variable only works for one conversation.
Real applications have multiple users, and each user may have multiple conversation threads.

---

## 3. Correct Solution: Using a Map (Dictionary)

To handle multiple conversations independently, replace the single global variable with a `Map`.

### Declaring the Map

-------------------code----------------------
const conversations = new Map<string, string>();
-------------------code----------------------

### Concept

Each conversation has its own identifier:

| Conversation ID | Last Response ID |
| --------------- | ---------------- |
| conv1           | 100              |
| conv2           | 200              |

### How It Works

1. The client sends a `conversationId` with every request.
2. When a new response arrives:

   -------------------code----------------------
   conversations.set(conversationId, response.id);
   -------------------code----------------------
3. When creating a new request:

   -------------------code----------------------
   previous_response_id: conversations.get(conversationId)
   -------------------code----------------------

---

## 4. Getting the Conversation ID from the Client

The route handler receives `conversationId` from the request body.

This works like ChatGPT itself:
Every new chat thread has a generated unique identifier visible in the URL.

---

## 5. Testing the Implementation

Using Postman:

1. Send a request with:

   * `conversationId: "conv1"`
   * Question: *What is the capital of France?*
2. Ask again:

   * Question: *What was my previous question?*
3. The raw tab shows the correct updated response even if the pretty tab does not refresh.

### Multiple Conversations

* Using `"conv1"`:

  * The system remembers the France-related question.
* Using `"conv2"`:

  * The system starts fresh and does not know the previous conversation.

This confirms the map tracks history separately for each conversation.

---

## 6. Notes on Real Applications

* In this simplified project, conversation IDs and response IDs are stored in memory.
* In real systems (like ChatGPT), memory is stored in a database.
* This project focuses on foundational concepts; database integration comes later in the course.

---


how to use Curl 

Below is the **correct, simple explanation** of how to use the `curl` command (often mistakenly spelled “carl”).
`curl` is a command-line tool used to send HTTP requests to servers.

I’ll explain it clearly, then show examples for your Flask/Express APIs.

---

# 1. Basic Format of a curl Request

-------------------code----------------------
curl [options] [URL]
-------------------code----------------------

---

# 2. Making a GET Request

Example:

-------------------code----------------------
curl http://localhost:3000/hello
-------------------code----------------------

---

# 3. Making a POST Request with JSON

This is the most common format when testing APIs.

-------------------code----------------------
curl -X POST URL -H "Content-Type: application/json" -d 'JSON_DATA'
-------------------code----------------------

Example:

-------------------code----------------------
curl -X POST http://localhost:3000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"conversationId":"conv1","message":"Hello"}'
-------------------code----------------------

---

# 4. Pretty Output (Show Response Nicely)

-------------------code----------------------
curl ... | jq
-------------------code----------------------

Example:

-------------------code----------------------
curl -X POST http://localhost:3000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"conversationId":"conv1","message":"test"}' | jq
-------------------code----------------------

---

# 5. Sending Headers

Example:

-------------------code----------------------
curl -H "Authorization: Bearer MYTOKEN" \
     http://localhost:3000/secure
-------------------code----------------------

---

# 6. POST with Form Data

-------------------code----------------------
curl -X POST -F "username=test" -F "password=123" http://localhost:3000/login
-------------------code----------------------

---

# 7. Save Output to a File

-------------------code----------------------
curl http://example.com/file.zip -o file.zip
-------------------code----------------------

---

# 8. Verbose Mode (Debug)

-------------------code----------------------
curl -v http://localhost:3000/api/chat
-------------------code----------------------

---

# 9. Example for Your Chat Memory API

The full working example for your code:

-------------------code----------------------
curl -X POST http://localhost:3000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"conversationId":"conv1", "prompt":"What is the capital of France?"}'
-------------------code----------------------

Follow-up:

-------------------code----------------------
curl -X POST http://localhost:3000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"conversationId":"conv1", "prompt":"What was my previous question?"}'
-------------------code----------------------

---

# 10. If You Want Shortcuts

### Use single quotes on Mac/Linux

### Use double quotes on Windows PowerShell

---


*** 2.4- Input Validation ***
---

# Data Validation with Zod

### Lecture Notes (Organized)

## 1. Why Validation Is Necessary

In real-world applications, we cannot assume all incoming data is valid.
We must ensure that:

* `prompt` is a string between 1 and 1000 characters
* `conversationId` is a valid UUID/GUID

These rules prevent invalid or malicious requests, and also protect the system from unnecessary token usage.

---

## 2. Installing Zod

In the server directory, run the following command to install Zod:

-------------------code----------------------
bun add zod
-------------------code----------------------

---

## 3. Defining a Validation Schema

### Import Zod

In `index.ts`:

-------------------code----------------------
import { z } from "zod";
-------------------code----------------------

### Create the Schema

Outside the route handler:

-------------------code----------------------
const chatSchema = z.object({
  prompt: z
    .string()
    .trim()
    .min(1, "prompt is required")
    .max(1000, "prompt is too long, maximum 1000 characters"),
  conversationId: z.uuid("invalid UUID"),
});
-------------------code----------------------

Notes:

* `.trim()` removes whitespace at the beginning and end.
* `.uuid()` ensures the string is a valid UUID.
* Using multiple lines improves readability.

---

## 4. Validating Incoming Data in the Route Handler

Inside the route handler:

-------------------code----------------------
const parsedResult = chatSchema.safeParse(req.body);

if (!parsedResult.success) {
  return res.status(400).json(parsedResult.error.format());
}
-------------------code----------------------

Explanation:

* `safeParse` returns an object indicating success or failure.
* On failure:

  * Status code `400` means "Bad Request"
  * `error.format()` provides structured error messages

If validation succeeds, the rest of the route handler executes normally.

---

## 5. Testing Validation in Postman

### 1. Passing an empty prompt

Sending `{ prompt: "", conversationId: "conv1" }` produces errors:

* prompt: "prompt is required"
* conversationId: "invalid UUID"

### 2. Passing whitespace only

Originally whitespace passed the min-length check.
Using `.trim()` fixes this issue by removing the whitespace before validation.

### 3. Passing a valid prompt

Example: `"What is the capital of France?"`

### 4. Generating a valid UUID

To test the request properly:

* Install a UUID generator extension in your editor
* Use the command palette to generate a UUID
* Replace `"conv1"` with the generated UUID

Send the request again. It should pass and the server will return a response from OpenAI.

---

*** 2.5- Error Handling ***
---

# Handling Unexpected Runtime Errors in the API

### Clean Notes (No Emojis)

## 1. Introduction

After adding basic input validation, the next step is to handle unexpected runtime errors in a proper and controlled way. The goal is to protect the API from exposing internal details and ensure the client receives a clear error message.

## 2. Why Error Handling Is Needed

The line where we call the OpenAI API can fail for several reasons:

* Network issues
* OpenAI servers being unavailable
* Exceeding token limits
* Incorrect model names or other invalid parameters

Currently, these errors are not handled, so they produce an HTML error response that exposes the full stack trace. This is not suitable for production.

## 3. Demonstrating the Problem

To simulate a runtime error, change the model name to something invalid by adding an exclamation mark.
When sending a request:

* The server returns an HTML error page
* The response includes the message “the requested model does not exist”
* The entire stack trace is visible

This is undesirable because API consumers expect structured JSON, not HTML, and internal details should not be leaked.

## 4. Adding Proper Error Handling

To fix this, wrap the logic inside a `try...catch` block.

### a. Try Block

Place all the code related to:

* Extracting the prompt and conversation ID
* Calling the OpenAI API
* Updating the conversations map
* Returning a successful response

Move all of it inside the `try` block for clarity and correctness.

### b. Catch Block

In case of any error:

* Set the response status to `500` (Internal Server Error)
* Return a JSON object such as:

  -------------------code----------------------
  { "error": "Failed to generate a response" }
  -------------------code----------------------

This ensures the client always receives a clean and consistent error structure.

## 5. Testing the Updated Error Handling

Send another request with the invalid model.
Now, instead of an HTML page with a stack trace, the API returns:

-------------------code----------------------
{ "error": "Failed to generate a response" }
-------------------code----------------------

This is the correct and safe behavior for a production-grade API.

---

*** 3- Refactoring the Chat API ***
---

## Lecture Notes: Refactoring and Layered Architecture

### 1. Problem Statement

* The current Chat API code is overloaded with responsibilities.
* A single file contains:

  * Conversation state management
  * Schema definitions
  * Data validation
  * Calls to OpenAI
* There is no separation of concerns.
* The result is code that is:

  * Hard to read
  * Hard to maintain
  * Hard to modify safely

**Analogy:**
The codebase is like a chaotic closet where everything is mixed together, making it difficult to find what you need.

---

### 2. What Is Refactoring?

* Refactoring means changing the **structure** of the code without changing its **behavior**.
* No new features are added.
* No functionality is removed.
* The goal is better organization and clarity.

**Analogy:**
Reorganizing a messy closet:

* You do not add or remove clothes.
* You simply move each item to where it belongs.

---

### 3. Goal of Refactoring

* Introduce clear structure into the codebase.
* Ensure that each part of the code has:

  * One purpose
  * One responsibility
* Improve maintainability, readability, and scalability.

---

### 4. Layered Architecture Overview

The application will be divided into multiple layers.
Each layer has a single, well-defined responsibility.

---

### 5. Controllers Layer

**Responsibility:**

* Handle HTTP requests.
* Return HTTP responses.

**Key Points:**

* Acts as the entry point to the application.
* Does not contain business logic.
* Delegates work to services.

**Analogy:**
A receptionist in a building who:

* Receives visitors (requests)
* Directs them to the right place
* Responds appropriately

---

### 6. Services Layer

**Responsibility:**

* Contain the core application and business logic.

**Key Points:**

* This is where actual processing happens.
* In the Chat API:

  * Calling OpenAI to generate responses belongs here.
* Controllers should call services, not implement logic themselves.

---

### 7. Repositories Layer

**Responsibility:**

* Handle data access and persistence.

**Key Points:**

* Used whenever data needs to be stored or retrieved.
* The source of data is abstracted:

  * Memory
  * Database
  * Any other storage system
* Other layers should not care where the data comes from.

---

### 8. Benefits of This Architecture

* **Maintainability**

  * Easy to locate and fix issues.
* **Readability**

  * Each layer has a clear and obvious purpose.
* **Scalability**

  * New features can reuse existing components.
* **Testability**

  * Each layer can be tested independently.
* **Reusability**

  * Logic can be plugged into new features without duplication.

---

### 9. Next Steps

* Over the next lessons:

  * The code will be refactored incrementally.
  * Each layer will be extracted one by one.
* The final result will be a clean, well-structured, and scalable codebase.

---

*** 3.1- Extracting Conversation Repository ***
## Lecture Notes: Repository Layer and Dependency Direction

### 1. Review: Layered Architecture Dependency Direction

* In layered architecture, **dependencies always flow from top to bottom**.
* Allowed dependencies:

  * Controllers → Services
  * Services → Repositories
* Disallowed dependencies:

  * Repositories should never depend on services or controllers.
* This ensures a clean, predictable structure.


---

### 2. The Repository Layer

* The **repository layer is the most fundamental layer** in the application.
* Its sole responsibility is **data access**.
* Anytime the application needs to:

  * Retrieve data
  * Store data
    it should do so through a repository.

---

### 3. Identifying Repository Responsibilities in Existing Code

* In the current codebase:

  * A map is used to track conversations.
  * There are statements for:

    * Getting the last response ID
    * Storing the last response ID
* These operations are clearly about **data storage and retrieval**.
* Therefore, they belong in the repository layer.

---

### 4. Creating the Repository Module

* Inside the `server` directory:

  * Create a new folder: `repositories`
  * Add a new file: `conversation.repository.ts`
* This file will encapsulate all conversation-related data access logic.

-------------------code----------------------
server/
├── index.ts
└── repositories/
    └── conversation.repository.ts
-------------------code----------------------


---

### 5. Moving Data Storage into the Repository

* The conversations map (in-memory storage) is:

  * Cut from `index.ts`
  * Moved into `conversation.repository.ts`
* At this point, data is stored in memory, which is an **implementation detail**.

---

### 6. Implementation Detail vs Public Interface

* Implementation detail:

  * How data is stored (e.g., memory, database).
* Public interface:

  * What functionality the module exposes to the outside world.

**Metaphor: Remote Control**

* Buttons on the outside: public interface.
* Internal electronics: implementation detail.
* Users interact only with the buttons, not the internal circuitry.

---

### 7. Designing the Repository Public Interface

* The repository should not export internal data structures.
* Instead, it should export **well-defined operations**.
* In this application, only two operations are needed:

  1. Get the last response ID
  2. Set the last response ID

---

### 8. Exporting Repository Functions

* Create and export:

  * `getLastResponseId(conversationId: string): string | undefined`
  * `setLastResponseId(conversationId: string, responseId: string): void`
* Move the corresponding logic from `index.ts` into these functions.
* Update `index.ts` to call these functions instead of directly accessing data.

-------------------code----------------------
// server/repositories/conversation.repository.ts

// Implementation detail (private)
// In-memory storage for conversations
const conversations = new Map<string, string>();

export const conversationRepository = {
  getLastResponseId(conversationId: string): string | undefined {
    return conversations.get(conversationId);
  },

  setLastResponseId(conversationId: string, responseId: string): void {
    conversations.set(conversationId, responseId);
  },
};
-------------------code----------------------

---

### 9. Benefits of Encapsulation

* `index.ts` no longer knows:

  * Where the data is stored
  * How it is stored
* If the repository later switches from in-memory storage to a database:

  * No changes are required in `index.ts`
* The rest of the application depends only on the repository’s public interface.

---

### 10. Improving Clarity: From Functions to Repository Object

* Problem:

  * Standalone functions resemble generic utilities.
  * Their architectural role is not immediately clear.
* Solution:

  * Export a repository object instead of individual functions.
-------------------code----------------------
// server/index.ts

const conversations = new Map<string, string>();

const lastResponseId = conversations.get(conversationId);

conversations.set(conversationId, response.id);
-------------------code----------------------


---

### 11. Exporting a Repository Object

* Export a constant:

  -------------------code----------------------
  conversationRepository
  -------------------code----------------------
* This object contains:

  * `getLastResponseId`
  * `setLastResponseId`
* Remove the standalone exported functions.
* This makes ownership and responsibility explicit.

---

### 12. Updating index.ts

* Import `conversationRepository`.
* Replace function calls with:

  * `conversationRepository.getLastResponseId(...)`
  * `conversationRepository.setLastResponseId(...)`
* This makes it clear that:

  * The code is interacting with the **conversation repository**
  * Not a generic helper or utility

-------------------code----------------------
// before refactoring
export function getLastResponseId(conversationId: string): string | undefined {
  return conversations.get(conversationId);
}

export function setLastResponseId(
  conversationId: string,
  responseId: string
): void {
  conversations.set(conversationId, responseId);
}

// after refactor encapsulate in object
export const conversationRepository = {
  getLastResponseId(conversationId: string): string | undefined {
    return conversations.get(conversationId);
  },

  setLastResponseId(conversationId: string, responseId: string): void {
    conversations.set(conversationId, responseId);
  },
};
-------------------code----------------------

---

### 13. Result of This Refactor

* Implementation details remain private.
* The repository layer is clearly defined.
* Dependencies follow the layered architecture rules.
* The code is more readable, maintainable, and flexible.

---

### 14. Next Step

* In the next lesson:

  * Introduce the **Chat Service**
  * The service will use the conversation repository
  * This continues building the layered architecture from the bottom up

---

*** 3.2- Extracting Chat Service ***
# Introducing the Service Layer

## Purpose of the Service Layer

* The service layer contains the **application logic**.
* Controllers act as **gateways**:

  * Receive HTTP requests
  * Validate input
  * Delegate work to services
* Services:

  * Must not know anything about HTTP requests or responses
  * Should only focus on business and application logic

In the Chat API:

* Code that works directly with `request` and `response` belongs to the **controller**.
* All logic between request validation and response formatting belongs to the **service**.

---

## Creating the Chat Service

### Folder Structure

* In the `server` directory, create a new folder:

  -------------------code----------------------
  server/services
  -------------------code----------------------
* Inside it, create a new file:

  -------------------code----------------------
  chat.service.ts
  -------------------code----------------------

---

## Initial Chat Service Implementation

### Public Interface

The service exports an object called `chatService` with a single method:

-------------------code----------------------
export const chatService = {
  sendMessage(prompt: string, conversationId: string) {
    // implementation
  }
};
-------------------code----------------------

Parameters:

* `prompt: string`
* `conversationId: string`

This method represents the **public interface** of the service.

---

## Moving Logic from the Controller to the Service

From the `index` module:

* Move the following into `chat.service.ts`:

  * The OpenAI call that generates a response
  * The logic that updates the `lastResponseId` in the conversation repository

### Import Dependencies

In `chat.service.ts`:

* Import the conversation repository
* Import OpenAI

Because `await` is used, mark the method as `async`:

-------------------code----------------------
async sendMessage(prompt: string, conversationId: string) {
  // async logic
}
-------------------code----------------------

---

## Encapsulating the LLM Client

### Moving the OpenAI Client

* Move the OpenAI client creation from `index.ts` into `chat.service.ts`.
* Use the editor shortcut:

  * macOS: `Cmd + P`
  * Windows: `Ctrl + P`
  * Type `@` to jump to a symbol (variable, function, constant)

### Important Design Decision

* The OpenAI client is an **implementation detail**.
* It must NOT be exported.
* This service is the **only module** that knows:

  * Which LLM is being used
  * How the LLM is configured

If the application switches from OpenAI to another LLM (e.g., Gemini), only this module should change.

---

## Simplifying the Controller (Index Module)

After refactoring:

* Remove imports for:

  * OpenAI
  * Conversation repository

The index module now:

* Extracts `prompt` and `conversationId` from the request body
* Calls the service:

-------------------code----------------------
const response = await chatService.sendMessage(prompt, conversationId);
-------------------code----------------------

---

## Fixing the Missing Return Value

Initially, the service does not return anything.

Inside `sendMessage`:

1. Generate the LLM response
2. Update the `lastResponseId` in the conversation repository
3. Return the response

---

## Identifying a Leaky Abstraction

### The Problem

* The service returns the raw OpenAI response object
* The controller accesses `response.output_text`

This is problematic because:

* `output_text` is **OpenAI-specific**
* Another LLM may return data in a different shape

Even though the service hides OpenAI usage, OpenAI-specific details are leaking outside.

This is known as a **leaky abstraction**.

---

## Introducing a Platform-Agnostic Response Type

### Defining a ChatResponse Interface

-------------------code----------------------
interface ChatResponse {
  id: string;
  message: string;
}
-------------------code----------------------

This represents a generic response from any LLM.

### Updating the Method Signature

-------------------code----------------------
async sendMessage(
  prompt: string,
  conversationId: string
): Promise<ChatResponse> {
  // implementation
}
-------------------code----------------------

---

## Mapping OpenAI Response to ChatResponse

The OpenAI response is converted into a platform-agnostic object:

-------------------code----------------------
return {
  id: response.id,
  message: response.output_text
};
-------------------code----------------------

Benefits:

* OpenAI-specific fields are contained in one place
* Switching LLM providers requires changes only in this service

The service now fully **encapsulates** LLM details.

---

## Updating the Controller to Use the New Interface

In the index module:

* Replace `output_text` with `message`

-------------------code----------------------
res.json({ message: response.message });
-------------------code----------------------

No LLM-specific logic remains in the controller.

---

## Summary

* Controllers handle HTTP concerns only
* Services contain application logic
* LLM usage is fully encapsulated in the Chat Service
* Platform-agnostic interfaces prevent leaky abstractions
* The codebase is cleaner, leaner, and easier to maintain
-------------------code----------------------
import { conversationRepository } from "../repositories/conversation.repository";
import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface ChatResponse {
  id: string;
  message: string;
}

export const chatService = {
  async sendMessage(
    prompt: string,
    conversationId: string
  ): Promise<ChatResponse> {
    const response = await client.responses.create({
      model: "gpt-5-mini",
      input: prompt,
      // NOTE: this is not support with GPT 5
      // temperature: 0.2,
      max_output_tokens: 100,
      previous_response_id:
        conversationRepository.getLastResponseId(conversationId),
    });

    conversationRepository.setLastResponseId(conversationId, response.id);
    return {
      id: response.id,
      message: response.output_text,
    };
  },
};
-------------------code----------------------

---

## Next Lesson

* Introducing the Controller layer in detail


*** 3.3- Extracting Chat Controller ***
# Introducing the Controller Layer

## Role of a Controller

* A controller is a **gateway** to the application.
* It is responsible for:

  * Receiving an HTTP request
  * Validating request data
  * Returning an error if the request is invalid
  * Calling one or more services to perform application logic
  * Returning an HTTP response to the client

Controllers deal with **HTTP concerns only**. They should not contain business logic.

---

## Goal of This Refactoring

* Move all logic from the route handler into a dedicated controller
* Keep the `index` module minimal and focused on routing
* Encapsulate request validation and request handling inside the controller

---

## Creating the Controller Module

### Folder Structure

In the `server` directory:

-------------------code----------------------
server/controllers
-------------------code----------------------

Inside this folder, create:

-------------------code----------------------
chat.controller.ts
-------------------code----------------------

---

## Chat Controller Public Interface

In `chat.controller.ts`, export an object called `chatController` with a single method:

-------------------code----------------------
sendMessage(req: Request, res: Response)
-------------------code----------------------

This method:

* Accepts an Express `Request`
* Accepts an Express `Response`
* Acts as the public interface of the controller

---

## Importing Express Types Explicitly

Instead of relying on inferred types, explicitly import them:

-------------------code----------------------
import type { Request, Response } from 'express';
-------------------code----------------------

This improves clarity and type safety.

---

## Moving Logic from the Route Handler

### Selecting the Code

* Use the editor shortcut for extending selection:

  * macOS: `Control + Shift + Command + Right`
* Extend the selection until:

  * The entire `try/catch` block is selected
  * The full body of the route handler is included

### Refactoring Step

* Cut the selected code from the route handler
* Paste it inside `chatController.sendMessage`
* Save the file

---

## Fixing Errors After Moving Code

After moving the code, several dependencies are missing.

### Importing the Chat Service

* The controller uses the chat service
* Import it at the top of the controller file

### Marking the Method as Async

* The method uses `await`
* Update the method signature:

-------------------code----------------------
async sendMessage(req: Request, res: Response)
-------------------code----------------------

---

## Moving the Validation Schema

### Locating the Schema

* Use the symbol search shortcut:

  * macOS: `Cmd + P`
  * Windows: `Ctrl + P`
* Type `@` and search for `chatSchema`

### Refactoring Step

* Extend the selection
* Cut the schema definition
* Move it into `chat.controller.ts`

### Importing Zod

-------------------code----------------------
import { z } from 'zod';
-------------------code----------------------

At this point, all errors in the controller should be resolved.

---

## Encapsulation and Implementation Details

### Key Design Principle

* `chatController` is the **public interface**
* Request validation is an **implementation detail**

The consumer of this module (the `index` module):

* Should not know which validation library is used
* Should not depend on Zod

Today the controller uses Zod.
Tomorrow it might use a different validation library.

Only the controller should change.
The index module must remain untouched.

---

## Updating the Index Module

### Replacing the Route Handler

Replace the inline lambda function with:

-------------------code----------------------
chatController.sendMessage
-------------------code----------------------

The index module now:

* Defines routes
* Delegates request handling to controllers

---

## Cleaning Up Imports

* Remove unused imports from the index module
* Shortcut:

  * macOS: `Cmd + .`
  * Windows: `Ctrl + .`

This further simplifies the index module.

---

## Resulting Architecture

* `index` module: routing only
* Controller: HTTP handling and validation
* Service: application logic
* Repository: data access

Each layer has a single responsibility.

---
-------------------code----------------------
import type { Request, Response } from "express";
import z from "zod";
import { chatService } from "../services/chat.service";

const chatSchema = z.object({
  prompt: z
    .string()
    .trim()
    .min(1, "prompt is required")
    .max(1000, "prompt is too long, maximum 1000 characters"),
  conversationId: z.uuid("invalid UUID"),
});

export const chatController = {
  async sendMessage(req: Request, res: Response) {
    try {
      const { prompt, conversationId } = req.body;

      const parsedResult = chatSchema.safeParse(req.body);

      if (!parsedResult.success) {
        return res.status(400).json(parsedResult.error.format());
      }

      const response = await chatService.sendMessage(prompt, conversationId);
      res.json({
        message: response.message,
      });
    } catch (error) {
      return res.status(500).json({
        error: "Failed to generate a response",
      });
    }
  },
};
-------------------code----------------------

## Next Refactoring

* One additional refactoring step remains
* This will be covered in the next lesson

*** 3.4- Extractring Routes ***
# Refactoring Route Definitions into a Routes Module

## Motivation

* Keeping all route definitions inside `index.ts` works for small projects.
* As an application grows, a single large file becomes difficult to read and maintain.
* Separating routes into their own module improves:

  * Code cleanliness
  * Modularity
  * Maintainability
  * Scalability as more endpoints are added

---

## Goal of This Lesson

* Move all route definitions out of `index.ts`
* Create a dedicated routes module
* Make `index.ts` responsible only for application startup

---

## Creating the Routes Module

### File Structure

In the `server` directory, create a new file:

-------------------code----------------------
routes.ts
-------------------code----------------------

---

## Setting Up the Routes File

### Importing Express

-------------------code----------------------
import express from 'express';
-------------------code----------------------

### Moving Route Definitions

* Go back to `index.ts`
* Select all route definitions
* Cut them and paste them into `routes.ts`

### Importing Express Types

Because route handlers use request and response types:

-------------------code----------------------
import type { Request, Response } from 'express';
-------------------code----------------------

---

## Using an Express Router Instead of the App

* The routes module should not work with the Express app instance directly.
* Instead, it should use an Express `Router`.

### Creating the Router

-------------------code----------------------
const router = express.Router();
-------------------code----------------------

### Registering Endpoints

* All endpoints are now registered on `router` instead of `app`.

---

## Renaming app to router Efficiently

### Multi-Cursor Editing

* Select the variable name `app`
* Use the shortcut for selecting all occurrences:

  * macOS: `Shift + Command + L`
  * Windows: `Shift + Control + L`

### Refactoring Step

* All instances of `app` are selected
* Replace them with `router`
* Exit multi-cursor mode by pressing `Esc` twice

---

## Importing the Controller

* Import `chatController` at the bottom or top of the routes file
* The controller methods are used as route handlers

### Design Note

* Ideally, routes should only reference controller methods
* Inline route handlers were kept temporarily for demonstration purposes
* Since they are simple one-liners, they are acceptable for now

---

## Exporting the Router

At the end of `routes.ts`:

-------------------code----------------------
export default router;
-------------------code----------------------

* A default export is used because this is the only object exposed by this module

---

## Updating index.ts

### Removing Unused Code

* Remove:

  * Inline route definitions
  * Direct imports of `chatController`

### Importing the Router

-------------------code----------------------
import router from './routes';
-------------------code----------------------

---

## Final index.ts Responsibilities

In `index.ts`:

1. Configure environment variables
2. Create the Express application
3. Register middleware (JSON parsing)
4. Register the router
5. Initialize the port
6. Start the server

### Readability Improvement

* Group related setup code together
* Add a line break between:

  * App setup
  * Port initialization and server start

The file now contains only startup-related logic.

---

## Architectural Review

After refactoring, the application is split into focused modules:

* **Routes**

  * Defines endpoints
  * Connects routes to controllers

* **Controller**

  * Acts as the gateway to the application
  * Handles HTTP requests and responses
  * Validates input
  * Delegates work to services

* **Service**

  * Contains application logic
  * Handles LLM calls and business rules

* **Repository**

  * Contains data access logic only
  * No HTTP concerns
  * No LLM logic

Each module has a single responsibility.

---

## Result

* `index.ts` is small, clean, and focused
* Application details are encapsulated in dedicated modules
* The codebase is easier to extend and maintain

---

## Next Steps

* Backend implementation is complete
* Upcoming lessons will focus on building the frontend


*** 4- Building the Frontend ***

### Development Approach

The frontend will be built incrementally, following a structured and deliberate process:

* Implement core functionality step by step
* Verify that each part works correctly before moving forward
* Ensure the chatbot behaves as expected at every stage

---

### Refactoring and Code Organization

Once the chatbot is fully functional:

* The code will be reviewed and refactored
* Responsibilities will be separated into clean, modular components
* Overall readability and maintainability will be improved

---

### Next Steps

* Begin implementing the chatbot UI and logic
* Gradually connect the frontend to the backend
* Prepare the codebase for future scaling and enhancements

This approach ensures a stable foundation while maintaining clean and organized frontend code.


*** 4.1- Building the ChatBot Component ***
---

## Lesson: Building the Chatbot Input Area (React + Tailwind)

### Objective

Build and style the input area of a chatbot, consisting of:

* A bordered container
* A borderless text area
* A round submit button positioned below the text area

---

## Component Structure

### Visual Structure

Although the button appears visually connected to the text area, the structure is:

* **Container** (bordered, rounded)

  * **Text area** (no border)
  * **Button** (round, positioned below and aligned right)

---

## Creating the Chatbot Component

### File Setup

1. Inside the `components` directory, create a new file:

   -------------------code----------------------
   chatbot.tsx
   -------------------code----------------------

2. Use the **ES7+ React/Redux/React-Native snippets** extension.

   * Type `rafce` to generate a React arrow function component.
   * Press `Esc` twice to exit multi-cursor mode.
   * Remove the unused `React` import.

---

## Component Markup

* Use a **container div**
* Inside it:

  * A native `<textarea>`
  * A `<button>` below it

### Why Native `<textarea>`?

The `shadcn/ui` textarea component includes default styles that would need to be overridden.
Using a native `<textarea>` is simpler and more efficient for this design.

---

## Using the Component

1. Go to the main `App` component.
2. Import and render the `Chatbot` component inside the container.
3. Remove:

   * Unused state variables
   * Unused `useEffect`
   * Related import statements

---

## Layout with Flexbox

### Vertical Layout

* Apply:

  * `flex`
  * `flex-col`

This stacks the textarea and button vertically.

### Spacing

* Add `gap-2` to create space between the elements.

---

## Button Alignment

### Align Button to the Right

* Use:

  * `items-end`

### Explanation

* In a vertical flex container:

  * **Main axis** → vertical
  * **Cross axis** → horizontal
* `items-end` aligns items to the end of the cross (horizontal) axis.

---

## Text Area Sizing

* Apply `w-full` to the textarea so it stretches to 100% width.

---

## Styling the Text Area

### Remove Border

* Apply `border-0`

### Remove Focus Outline

* Browsers add outlines on focus by default.
* Remove it using:

  * `focus:outline-0`

### Disable Resize Handle

* Apply `resize-none`

---

## Styling the Container

1. Add a border:

   * `border-2`
2. Add padding:

   * `p-4`
3. Round the corners:

   * `rounded-3xl`

---

## Styling the Button

### Adding an Icon

1. Install React Icons:

   -------------------code----------------------
   bun add react-icons
   -------------------code----------------------
2. Choose an icon (e.g., Font Awesome up arrow).
3. Import and use it as a React component:

   * `FaArrowUp`

Replace the button label with the icon.

---

### Making the Button Perfectly Round

1. Apply:

   * `rounded-full`
2. Fix the shape issue:

   * Buttons must be square to be fully round.
3. Set fixed dimensions:

   * `w-9`
   * `h-9`

Result: a perfectly circular button.

---

## Final Enhancements

### Placeholder Text

* Add to the textarea:

  -------------------code----------------------
  placeholder="Ask anything"
  -------------------code----------------------

### Max Length

* Set:

  -------------------code----------------------
  maxLength={1000}
  -------------------code----------------------

This matches the backend API validation rule.

---

-------------------code----------------------
import { FaArrowUp } from "react-icons/fa";
import { Button } from "./ui/button";
const ChatBot = () => {
  return (
    <div className="flex flex-col gap-2 items-end border-2 p-4 rounded-3xl">
      <textarea
        className="w-full border-0 focus:outline-0 resize-none"
        placeholder="Ask anything"
        maxLength={1000}
      />
      <Button className="rounded-full w-9 h-9 flex items-center justify-center border">
        <FaArrowUp />
        {/* another style */}
        {/* <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 448 512"
          className="w-4 h-4"
          fill="currentColor"
        >
          <path d="M438.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L338.7 288H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H338.7L233.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z" />
        </svg> */}
      </Button>
    </div>
  );
};

export default ChatBot;
-------------------code----------------------


## Lesson Wrap-Up

* The chatbot input UI is complete.
* Layout and styling are finalized.
* The next lesson will focus on **submitting the form and handling user input**.

---

*** 4.2- Handling Form Submission ***
## Lesson: Handling Form Submission with React Hook Form

### Objective

Make the chatbot form functional by handling form submission, validation, and user interactions using **React Hook Form**.

---

## Installing React Hook Form

1. Open a terminal in the **client** directory.
2. Install the library:

-------------------code----------------------
bun add react-hook-form
-------------------code----------------------

---

## Setting Up the Form

### Importing the Hook

In the chatbot component, import the `useForm` hook from React Hook Form.

---

## Defining Form Data

Create a type to represent the structure of the form:

* The form contains a single field:

  * `prompt`: string

This type will be used to strongly type the form data throughout the component.

---

## Initializing `useForm`

Call `useForm` and provide the form data type as a generic argument.

From the returned object, destructure the following at minimum:

* `register`
* `handleSubmit`

Later, additional properties will be added as needed.

---

## Registering the Text Area

* Use the `register` function to register the `<textarea>` input.
* Pass `"prompt"` as the field name.

  * This name is type-safe and auto-suggested based on the form data type.
* Add validation options:

  * Mark the field as required.

### Spreading Input Props

The `register` function returns an object containing multiple input props (e.g., `onChange`, `onBlur`, `maxLength`).

* Spread this object directly into the `<textarea>` to apply all required behavior.

---

## Converting the Container to a Form

* Replace the wrapping `<div>` with a `<form>`.
* Use multi-cursor editing:

  * Select the tag
  * Use **Add Next Occurrence** (`Cmd + D` on macOS, `Ctrl + D` on Windows)
  * Replace both opening and closing tags at once

---

## Handling Form Submission

### `onSubmit` Prop

* Add the `onSubmit` prop to the `<form>`.
* Pass `handleSubmit` to it.

### Submit Callback

* Provide an arrow function that:

  * Receives validated form data
  * Has the correct inferred type
* Initially, log the data to the console to verify behavior.

### Testing

* Submit the form from the browser.
* Confirm that the submitted object contains the `prompt` field.

---

## Resetting the Form After Submission

### Adding `reset`

* Destructure `reset` from `useForm`.

### Creating a Dedicated Submit Handler

* Define a function named `onSubmit`:

  * Accepts form data
  * Logs the data
  * Calls `reset()` to clear the form

Replace the inline arrow function with a reference to this handler.

---

## Submitting with the Enter Key

### Desired Behavior

* Pressing **Enter** submits the form.
* **Shift + Enter** inserts a new line.

### Handling `onKeyDown`

* Attach an `onKeyDown` handler to the textarea.
* Check:

  * `e.key === "Enter"`
  * `e.shiftKey === false`

If both conditions are met:

* Prevent the default behavior
* Trigger form submission

---

## Understanding `handleSubmit`

* `handleSubmit(onSubmit)` returns a function.
* When calling it manually (e.g., from `onKeyDown`), you must invoke it:

  * `handleSubmit(onSubmit)()`

This differs from passing a function reference in JSX.

---

## Extracting the Keydown Logic

### Creating a Separate Function

* Move the keydown logic into a dedicated function:

  * `onKeyDown`

### Typing the Event

* Explicitly annotate the event parameter:

  * `KeyboardEvent<HTMLFormElement>`

This is required because TypeScript cannot infer the type when the function is declared separately.

---

## Enabling and Disabling the Submit Button

### Using `formState`

* Destructure `formState` from `useForm`.
* Use `formState.isValid` to control the button state.

### Button Logic

* Disable the button when the form is not valid.
* Keep behavioral props before styling props for consistency.

---

## Improving Validation Logic

### Problem

* A string containing only spaces passes the `required` check.

### Solution

* Add a custom `validate` function to the `register` options:

  * Trim the input
  * Ensure the length is greater than zero

### Result

* Whitespace-only input is rejected.
* The form becomes valid only when meaningful input is entered.

---

## Lesson Wrap-Up

* Form submission is fully handled.
* The input resets after submission.
* Enter and Shift + Enter behave as expected.
* Validation is robust and user-friendly.

### Next Step

The form data is now ready to be sent to the backend.
The next lesson will focus on **posting the prompt to the server**.


*** 4.3- Calling the Backend ***

## Lesson: Posting Chat Data to the Server with Axios

### Objective

Send the chatbot prompt from the frontend to the backend using an HTTP POST request, attach a persistent conversation ID, and handle the server response.

---

## Choosing an HTTP Client

### Fetch vs Axios

Two common options exist for making HTTP requests:

* `fetch`
* `axios`

Axios is preferred because it:

* Automatically parses JSON responses
* Has built-in error handling
* Supports request cancellation
* Provides a cleaner and more readable API

---

## Installing Axios

From the **client** directory:

-------------------code----------------------
bun add axios
-------------------code----------------------

---

## Import Order Convention

Imports should follow this order:

1. Third-party libraries
2. Internal UI components
3. Local application logic

This keeps files consistent and readable.

---

## Creating a Conversation ID

### Why a Conversation ID?

* Each chatbot session needs a unique identifier
* Allows the backend to keep conversation context

---

### Why `useRef` Instead of `useState`?

* The conversation ID:

  * Should be created only once
  * Should not change
  * Should not trigger re-renders

`useRef` is ideal for storing:

* IDs
* Timers
* Mutable values unrelated to UI rendering

---

### Generating the ID

* Use the browser’s built-in `crypto.randomUUID()`
* Store it in a ref
* Access it using `.current`

---

## Sending Data to the Server

### Endpoint

-------------------code----------------------
POST /api/chat
-------------------code----------------------

### Request Payload

* `prompt`
* `conversationId`

---

## Resetting the Form

* Call `reset()` **before** making the HTTP request
* Reason:

  * Server calls may take time
  * The input should clear immediately for better UX

---

## Handling the Server Response

* Mark the submit handler as `async`
* Await the Axios request
* Destructure the `data` property from the response
* Log the response for verification

---

## Updated ChatBot Component (Full Code)

-------------------code----------------------
import axios from "axios";
import { useForm } from "react-hook-form";
import { useRef, KeyboardEvent } from "react";
import { FaArrowUp } from "react-icons/fa";
import { Button } from "./ui/button";

type FormData = {
  prompt: string;
};

const ChatBot = () => {
  const conversationId = useRef<string>(crypto.randomUUID());

  const {
    register,
    handleSubmit,
    reset,
    formState,
  } = useForm<FormData>({
    mode: "onChange",
  });

  const onSubmit = async ({ prompt }: FormData) => {
    reset();

    const { data } = await axios.post("/api/chat", {
      prompt,
      conversationId: conversationId.current,
    });

    console.log(data);
  };

  const onKeyDown = (e: KeyboardEvent<HTMLFormElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(onSubmit)();
    }
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      onKeyDown={onKeyDown}
      className="flex flex-col gap-2 items-end border-2 p-4 rounded-3xl"
    >
      <textarea
        className="w-full border-0 focus:outline-0 resize-none"
        placeholder="Ask anything"
        maxLength={1000}
        {...register("prompt", {
          required: true,
          validate: (value) => value.trim().length > 0,
        })}
      />

      <Button
        disabled={!formState.isValid}
        className="rounded-full w-9 h-9 flex items-center justify-center border"
      >
        <FaArrowUp />
      </Button>
    </form>
  );
};

export default ChatBot;
-------------------code----------------------

---

## Lesson Wrap-Up

* The frontend now sends chat prompts to the backend
* Each request includes a persistent conversation ID
* The form resets immediately after submission
* Server responses are received and verified

### Next Lesson

The next step is **rendering chat messages in the UI** and building the conversation history display.


*** 4.4- Rendering the Messages ***

---

## Rendering Chat Messages with React State and TypeScript

### 1. Declaring State for Messages

* To render chat messages, we declare a state variable using the `useState` hook.
* The state should be an array of strings.
* We initialize it as an empty array.

-------------------code----------------------
const [messages, setMessages] = useState<string[]>([]);
-------------------code----------------------

* `messages` holds all chat messages.
* `setMessages` is used to update the list.

---

### 2. Adding Messages on Form Submission

#### Adding the User Prompt

* When the form is submitted, the first step is to add the user’s prompt to the messages array.
* We do this by copying the existing messages and appending the new prompt.

-------------------code----------------------
setMessages([...messages, prompt]);
-------------------code----------------------

#### Adding the Server Response

* Once we receive a response from the server, we add it to the messages list instead of logging it.
* The server response is an object, not a string.
* The actual message is stored in `data.message`.

-------------------code----------------------
setMessages([...messages, data.message]);
-------------------code----------------------

---

### 3. Fixing TypeScript IntelliSense for Server Responses

#### The Problem

* When typing `data.message`, TypeScript does not provide IntelliSense.
* This happens because TypeScript does not know the shape of the server response.

#### The Solution: Define a Response Type

* We define a new type that matches the server response.

-------------------code----------------------
type ChatResponse = {
  message: string;
};
-------------------code----------------------

* We then pass this type as a generic argument to `axios.post`.

-------------------code----------------------
const { data } = await axios.post<ChatResponse>(url, payload);
-------------------code----------------------

* Now TypeScript understands that `data` has a `message` property.
* IntelliSense works correctly.

---

### 4. Structuring the Markup

#### Wrapping the Form in a Container

* The form is wrapped inside a `div` to act as a container.
* This is done using the “Wrap with Abbreviation” command in the command palette.

  * macOS: `Shift + Command + P`
  * Windows: `Shift + Control + P`
* Choose `Wrap with Abbreviation`, type `div`, and press Enter.

#### Messages Container

* Inside the main container, add another `div` to render messages.

---

### 5. Rendering Messages with `map`

* We use `messages.map()` to render each message.
* Each message is displayed inside a `<p>` tag.

-------------------code----------------------x
{messages.map((message, index) => (
  <p key={index}>{message}</p>
))}
-------------------code----------------------

#### Keys in React

* Since we are rendering a list, each element must have a `key`.
* We use the index as the key.
* This is standard React practice and should already be familiar.

---

### 6. Bug: Messages Overwriting Each Other

#### What Happens

* After testing, the server response overwrites the user prompt.
* Instead of seeing both messages, only the last one appears.

#### Why This Happens

* There are two calls to `setMessages`.
* Both calls reference the same stale version of the `messages` array.
* That version is the initial empty array.
* As a result:

  * The first update adds the prompt to an empty array.
  * The second update also starts from an empty array and adds only the server response.

---

### 7. Fix: Using the Functional State Update Pattern

* To ensure React uses the latest state, we use the functional form of `setMessages`.

#### Updating with the Latest State

-------------------code----------------------
setMessages(prev => [...prev, prompt]);
-------------------code----------------------

-------------------code----------------------
setMessages(prev => [...prev, data.message]);
-------------------code----------------------

* `prev` represents the most recent version of the state.
* This guarantees that messages are appended correctly.

---

### 8. Final Result

* After applying the fix:

  * The user prompt is displayed.
  * The server response appears below it.
* The issue is resolved.
* The application is now ready for styling the messages.

---

### 9. Next Step

* With message rendering working correctly, the next lesson focuses on styling the chat messages.
