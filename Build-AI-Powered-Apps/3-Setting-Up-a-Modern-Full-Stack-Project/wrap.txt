*** 1- Introduction ***
---

# Full Stack Project Setup

### Course Foundation Overview

## 1. Introduction

Before building the application, we need to set up a clean, modern full stack project. This project will serve as the foundation for everything covered throughout the course.

## 2. Why Not Use Existing Templates

There are many templates and GitHub starter projects for full stack applications, but this course does not rely on them because:

* We want full control over the setup.
* We avoid depending on someone else’s configuration.
* We do not want to introduce tools that have not yet been explained.

## 3. Why Not Use Next.js

Although Next.js is a powerful full stack framework built on React:

* It has its own learning curve.
* Not everyone likes using it.
* The course should not require Next.js knowledge beforehand.

Instead, the entire setup will be built manually for clarity and flexibility.

## 4. Tools Used in the Setup

The project will be built from scratch using the following technologies:

### Core Tools

* **Bun**: For package management and running the development environment.
* **Vite**: For creating and bundling the frontend.
* **Express**: For building the backend API.

### Additional Tools

* **Tailwind CSS**: For styling the frontend.
* **ShadCN UI**: For reusable UI components.
* **Prettier**: For formatting the codebase.
* **Husky**: For automating workflows, such as pre-commit checks.

## 5. Outcome of This Section

By the end of this part of the course, you will have:

* A fully configured full stack foundation.
* A lightweight and scalable structure.
* A setup that is clean, transparent, and easy to understand.
* A development environment fully customized and owned by you.

## 6. Next Steps

With the tools and structure planned, the next step is to begin the actual setup and configuration of the project.

---

*** 2- Setting Up Bun ***
---

# Introduction to Bun

### A Modern JavaScript Runtime for This Course

## 1. What Is Bun

* Bun is a modern JavaScript runtime similar to Node.js.
* It is designed to be faster and more integrated than the traditional Node.js toolchain.

## 2. Why Use Bun

With Node.js, developers typically rely on several separate tools:

* **npm** for package installation
* **ts-node** for running TypeScript
* **nodemon** for automatically restarting the server

Bun replaces all of these by providing:

* A JavaScript and TypeScript runtime
* A package manager
* A task runner
* A built-in TypeScript transpiler

This means Bun can run TypeScript files directly without requiring additional tools.

## 3. Compatibility with Node.js

* If someone prefers using Node.js, everything taught in the course can still be done with Node.
* However, Bun generally offers a cleaner and more enjoyable development experience.

## 4. Installing Bun

### Steps

1. Go to **bun.sh**.
2. On the homepage, locate the installation command for your operating system.
3. Copy the command and run it in your terminal.
-------------------code----------------------
curl -fsSL https://bun.com/install | bash
-------------------code----------------------
4. Follow the terminal instructions.

   * On macOS, for example, you may need to run:

     -------------------code----------------------
     exec /bin/zsh
     -------------------code----------------------

## 5. Verify Installation

After installation, run:

-------------------code----------------------
bun --version
-------------------code----------------------

Example:

* The instructor is using Bun version **1.2.17**.

## 6. Next Lesson

The next part of the course will cover the project structure.

---


*** 3- Creating the Project Structure ***

---

# Creating the Project Structure

### Setting Up a Full Stack Workspace with Bun

## 1. Create the Main Project Directory

1. Open a terminal window.
2. Navigate to the desired location (for example, the desktop).
3. Create a new directory for the project:

   -------------------code----------------------
   mkdir app
   -------------------code----------------------
4. Move into the directory:

   -------------------code----------------------
   cd app
   -------------------code----------------------

## 2. Initialize the Project with Bun

Run:

-------------------code----------------------
bun init
-------------------code----------------------

### What This Does

* Similar to `npm init`.
* Generates a `package.json` file.
* Creates additional project files.
* Installs TypeScript automatically.

### Template Selection

When prompted to choose a template:

* Options: `blank`, `react`, `library`.
* Choose **blank**.

### Files Created

* `.gitignore`
* A directory for Cursor editor rules (safe to delete if not using Cursor)
* `index.ts` (initial file with a simple console log)
* `tsconfig.json`
* `README.md`
* `node_modules`
* `bun.lockb`

Open the project folder in VS Code.

## 3. Preparing for a Full Stack Architecture

To manage a frontend (client) and backend (server) within a single project, we will use **Bun workspaces**.

### What Are Workspaces

* A built-in feature in Bun (also available in Node with other tools).
* Allows managing multiple sub-projects under one root project.
* Useful for monorepos containing separate client and server apps.

## 4. Creating the Workspace Structure

1. Inside the root project, create a new directory:

   -------------------code----------------------
   packages
   -------------------code----------------------
2. Inside `packages`, create two subdirectories:

   * `client`
   * `server`

Final folder structure:

-------------------code----------------------
app
 ├── packages
 │    ├── client
 │    └── server
 ├── package.json
 ├── tsconfig.json
 ├── index.ts
 ├── node_modules
 └── other config files
-------------------code----------------------

## 5. Declaring Workspaces in package.json

Open `package.json` and add a new property:

-------------------code----------------------json
{
  "workspaces": ["packages/*"]
}
-------------------code----------------------

### Explanation

* `packages/*` is shorthand for including all subfolders inside `packages` as workspaces.
* No need to list each folder individually.

## 6. Initialize Git

To version-control the project:

1. Run:

   -------------------code----------------------
   git init
   -------------------code----------------------
2. Create the first commit:

   -------------------code----------------------
   git add .
   git commit -m "Initial commit"
   -------------------code----------------------

## 7. Next Steps

In upcoming lessons, the client and server subprojects will be created independently inside the workspace structure.

---


*** 4- Creating the Backend ***
---

# Creating the Server Application

### Setting Up the Backend with Bun and Express

## 1. Initialize the Server Subproject

1. In the terminal, navigate to the server directory:

   -------------------code----------------------
   cd packages/server
   -------------------code----------------------
2. Run:

   -------------------code----------------------
   bun init
   -------------------code----------------------
3. Choose the **blank** template.

This creates the same starter files as before.
Remove the unused Cursor directory to keep the project clean.

---

# 2. Install Dependencies

## Install Express

Bun uses `bun add` instead of `npm install`:

-------------------code----------------------
bun add express
-------------------code----------------------

## Install Type Definitions for TypeScript

-------------------code----------------------
bun add -d @types/express
-------------------code----------------------

After installation, the `package.json` inside `packages/server` will contain:

* `express` as a dependency
* `@types/express` as a development dependency

Note:
The workspace uses a single top-level `node_modules` directory.
Client and server do not have separate `node_modules` folders.

---

# 3. Creating the Web Server

Open `packages/server/index.ts`.

## Import Express

-------------------code----------------------
import express from "express";
-------------------code----------------------

## Create the Express Application

-------------------code----------------------
const app = express();
-------------------code----------------------

## Configure the Port

Use an environment variable if available; otherwise default to 3000:

-------------------code----------------------
const port = process.env.PORT || 3000;
-------------------code----------------------

## Define a Route

-------------------code----------------------
app.get("/", (req, res) => {
  res.send("Hello World");
});
-------------------code----------------------

## (Optional) Add Type Annotations

-------------------code----------------------
import type  { Request, Response } from "express";

app.get("/", (req: Request, res: Response) => {
  res.send("Hello World");
});
-------------------code----------------------

## Start the Server

-------------------code----------------------
app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
-------------------code----------------------

---

# 4. Running the Server

In the server directory:

-------------------code----------------------
bun run index.ts
-------------------code----------------------

Click the printed URL (on macOS using Command + click) to open it in the browser.

---

# 5. Adding Custom Scripts

Open **packages/server/package.json**
Add a `scripts` section:

-------------------code----------------------
{
  "scripts": {
    "start": "bun run index.ts",
    "dev": "bun --watch run index.ts"
  }
}
-------------------code----------------------

### Explanation

* `start`: Runs the application normally.
* `dev`: Runs the server in watch mode so it restarts automatically on file changes.

---

# 6. Running Scripts

## Start the Server

-------------------code----------------------
bun start
-------------------code----------------------

## Run in Watch Mode

Because `dev` is a custom script:

-------------------code----------------------
bun run dev
-------------------code----------------------

Changing the server code (for example removing an exclamation mark in the response) will automatically restart the server, and refreshing the browser will show the updated output.

---


*** 5- Managing OpenAI API Key ***
---

# Managing API Keys and Environment Variables

## 1. Why API Keys Should Not Be Stored in Source Code

* Never hardcode sensitive values such as API keys in files like `index.ts`.
* Anyone with access to the source code could use the key and cause unwanted usage charges.
* The correct approach is to use environment variables.

---

# Setting Environment Variables Manually

## 2. Setting a Temporary Environment Variable in the Terminal

* Stop the running server.
* On macOS/Linux:

  -------------------code----------------------
  export OPENAI_API_KEY=1234
  -------------------code----------------------
* On Windows:

  -------------------code----------------------
  set OPENAI_API_KEY=1234
  -------------------code----------------------
* Environment variables are conventionally written in uppercase.

## 3. Reading Environment Variables in Code

In `index.ts`, use:

-------------------code----------------------
process.env.OPENAI_API_KEY
-------------------code----------------------

* Temporarily return this value in a route handler to verify it is received correctly.

## 4. Restart and Test

* Start the server again.
* Refresh the browser.
* The value is read successfully.

---

# The Problem with Manual Environment Variables

* Each time you start the application, you would have to manually set the variables.
* This is repetitive and error-prone.

---

# Using the `dotenv` Library

## 5. Install dotenv

In the server project directory:

-------------------code----------------------
bun add dotenv
-------------------code----------------------

## 6. Create a `.env` File

Inside `packages/server`:

-------------------code----------------------
.env
-------------------code----------------------

* `.env` files are ignored by Git automatically (verified in `.gitignore`).
* Declare variables inside:

-------------------code----------------------
OPENAI_API_KEY=ABCD
-------------------code----------------------

## 7. Load `.env` Variables in Code

At the top of `index.ts`:

-------------------code----------------------
import dotenv from "dotenv";
dotenv.config();
-------------------code----------------------

* This must be the first line in the file.
* It loads all key-value pairs from `.env` into `process.env`.

## 8. Restart the Application

* Restart the server.
* You will see a message:
  `dotenv is injecting environment variables`
* However, if you previously set the variable in the terminal, the terminal version overrides `.env`.

---

# Removing Old Environment Variables

## 9. Remove the Terminal Variable

On macOS/Linux:

-------------------code----------------------
unset OPENAI_API_KEY
-------------------code----------------------

On Windows:

-------------------code----------------------
set OPENAI_API_KEY=
-------------------code----------------------

* Restart the server again.
* Now the value from `.env` appears correctly.

---

# Using a Real API Key

## 10. Replace the Placeholder Value

In `.env`:

-------------------code----------------------
OPENAI_API_KEY=your_real_api_key_here
-------------------code----------------------

---

# Providing a Template for Others

## 11. Create `.env.example`

Duplicate `.env` and name it:

-------------------code----------------------
.env.example
-------------------code----------------------

* This file is included in the repository.
* It lists variable names without actual values:

-------------------code----------------------
OPENAI_API_KEY=
-------------------code----------------------

* This helps other developers understand what they must configure.

---

# Final Cleanup

## 12. Restore Main Route Output

Replace temporary code with the original response:

-------------------code----------------------
res.send("Hello World");
-------------------code----------------------

## 13. Commit the Changes

Commit message example:

-------------------code----------------------
manage openai api key
-------------------code----------------------

---

# Important Note

* If you change anything inside the `.env` file, Bun will not reload it automatically.
* You must manually restart the application each time you update `.env`.

---


*** 6- Creating the Frontend ***
---

# Setting Up the Front-End Application with Vite

## 1. Introduction to Vite

* Vite is a fast, modern build tool for front-end applications.
* Commonly used for React, Vue, and other frameworks.
* Documentation: vite.dev

---

# Creating the Front-End Project

## 2. Navigate to the Vite Documentation

* On vite.dev, go to "Get Started".
* The official command for creating a project with npm is:

  -------------------code----------------------
  npm create vite@latest
  -------------------code----------------------
* Vite also supports Bun.

---

## 3. Prepare the Workspace in VS Code

* Open a new terminal window.
* For better organization, use two terminals:

  * One for the **server**
  * One for the **client**
* Rename terminal tabs accordingly:

  * Server terminal → rename to `server`
  * Client terminal → rename to `client`
* Optional: color-code them for clarity (example: server green, client yellow).

---

# Creating the Client Project

## 4. Navigate to the Correct Directory

-------------------code----------------------
cd packages/client
-------------------code----------------------

## 5. Run the Vite Creation Command

* Paste the Vite command:

  -------------------code----------------------
  bun create vite
  -------------------code----------------------
* Do **not** run it immediately.
* If executed directly, Vite will create a **subdirectory**, which is not desired.
* Instead, append a period (`.`) to create the project **in the current directory**:

  -------------------code----------------------
  bun create vite .
  -------------------code----------------------

## 6. Choose the Project Options

* **Framework:** React
* **Variant:** TypeScript

---

# Project Structure

## 7. Resulting Directory

Inside `packages/client`, Vite generates a standard React project structure.
You will now have:

* A `package.json` for the client
* A `package.json` for the server
* A root `package.json`

Total: **three** `package.json` files.

---

# Installing Dependencies

## 8. Install Dependencies with Bun

In the root of the project (workspace root):

-------------------code----------------------
bun install
-------------------code----------------------

* This installs all dependencies into **one shared top-level `node_modules`** directory.
* You will **not** have separate `node_modules` folders for client and server.

---

# Running the Client Application

## 9. Start the Development Server

Inside the client terminal:

-------------------code----------------------
bun run dev
-------------------code----------------------

* The `dev` script comes from `packages/client/package.json`.

Example scripts section:

-------------------code----------------------json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint ."
  }
}
-------------------code----------------------

## 10. Verify the Application

* Open the displayed local development URL in the browser.
* You should see the default React + Vite project running successfully.

---

# Final Step

## 11. Make a Git Commit

Commit message example:

-------------------code----------------------
create frontend
-------------------code----------------------

This marks the completion of setting up the client-side project.

---

*** 7- Connecting the Frontend and Backend ***
---

# Connecting the Client and Server Applications

### Lecture Notes

## 1. Creating a New Endpoint in the Server Application

1. Open the server application and navigate to `index.ts` in the server directory.
2. Duplicate an existing route handler using the shortcut:

   * macOS: **Option + Shift + Down Arrow**
   * Windows: **Shift + Alt + Down Arrow**
3. Modify the duplicated route:

   * Change the path to `/api/hello`.
   * Return a JSON object instead of plain text:

-------------------code----------------------
app.get("/api/hello", (req: Request, res: Response) => {
  res.json({ message: "Hello World!" });
});
-------------------code----------------------

4. Test the new endpoint in the browser by visiting `/api/hello`.
5. If the JSON is not formatted, install the "JSON Formatter" browser extension.

---

## 2. Preparing the Client Application (React)

### Cleaning Up `app.tsx`

1. Open `app.tsx`.
2. Remove all import statements and all existing code inside the component.
3. Use the selection expansion shortcut:

   * macOS: **Control + Shift + Command + Right Arrow**
   * Right Arrow expands selection, Left Arrow shrinks it.
4. Select the needed block and delete it.

---

## 3. Adding State and Effect Hooks

### Declare State

-------------------code----------------------
const [message, setMessage] = useState("");
-------------------code----------------------

### Make an API Call with `useEffect`

1. Use the `fetch` API to call `/api/hello`.
2. Convert the response to JSON.
3. Set `message` to `data.message`.
4. Provide an empty dependency array so the effect runs once.

### Render Output

Return a simple paragraph that displays the message:

-------------------code----------------------
<p>{message}</p>
-------------------code----------------------

---

## 4. Why the Request Fails Initially

If you call `/api/hello` from the client, it fails because that endpoint only exists on the server.
The client development server needs to forward API requests to the backend.

---

## 5. Setting Up a Proxy in Vite

1. Open `vite.config.ts`.
2. Add a `server` property with a `proxy` configuration:

   -------------------code----------------------
   server: {
     proxy: {
       "/api": "http://localhost:3000"
     }
   }
   -------------------code----------------------


3. This ensures:

   * Requests to `/api/...` from the client automatically forward to
     `http://localhost:3000/api/...`.

4. restart the server and client
---

## 6. Testing the Integrated Application

1. Refresh the client application in the browser.
2. The "hello world" message should appear.
3. It may be centered due to default styles.

---

## 7. Fixing Client Styling

1. Open `index.css` in the client.
2. Remove all default styles.
3. Refresh the browser and confirm the layout looks correct.

---

## 8. Final Step: Commit the Changes

Use a clear commit message, such as:
**"Connect the front end and back end."**

---

*** 8- Running Both Apps Together ***
---

# Running Server and Client with a Single Command

### Lecture Notes

## 1. Problem: Two Terminals Needed

In the current setup, starting the application requires:

* One terminal to run the server: `bun run dev`
* Another terminal to run the client: `bun run dev`

This becomes repetitive and inefficient.

---

## 2. Goal

Start **both** the server and client applications simultaneously using **one command**.

---

## 3. Install Concurrently

1. Stop both the client and server.
2. Open a new terminal at the **root** of the project.
3. Install the dependency:

   -------------------code----------------------
   bun add -d concurrently
   -------------------code----------------------

`concurrently` lets you run multiple commands in parallel.

---

## 4. Create a Root-Level `index.ts`

Inside the **root directory**, open or create `index.ts`.

### Remove old console logs

Delete any existing console log statements.

### Import and use concurrently

-------------------code----------------------
import concurrently from "concurrently";

concurrently([
  {
    name: "server",
    command: "bun run dev",
    cwd: "packages/server",
    prefixColor: "cyan"
  },
  {
    name: "client",
    command: "bun run dev",
    cwd: "packages/client",
    prefixColor: "green"
  }
]);
-------------------code----------------------

### Explanation of properties

* **name**: identifies the process in the terminal.
* **command**: the command used to start the app.
* **cwd**: directory from which the command should run.
* **prefixColor** (optional): assigns a color so messages are easier to read in a single terminal window.

---

## 5. Add a Custom Script in Root `package.json`

Open the **package.json** in the root directory and create a new script:

-------------------code----------------------
{
  "scripts": {
    "dev": "bun run index.ts"
  }
}
-------------------code----------------------

This allows running both apps with a single command.

---

## 6. Run Both Applications

In the **root directory**, run:

-------------------code----------------------
bun run dev
-------------------code----------------------

Both apps will start at once:

* Server logs appear in cyan
* Client logs appear in green

---

## 7. Test the Setup

1. Open the browser.
2. Refresh the client application.
3. Confirm that everything loads correctly.

---

## 8. Wrap Up

Since both applications now start through one root command:

* Individual server/client terminals are no longer needed.
* You can make a commit with a message like:
  **run both apps together**

---

*** 9- Setting Up TailwindCSS ***
---

# Styling the Application with Tailwind CSS

### Lecture Notes

## 1. Introduction to Tailwind CSS

* Tailwind CSS is a **utility-first CSS framework**.
* It provides small, descriptive CSS classes such as:

  * `flex`
  * `pt-4` (padding-top: 1rem)
  * `text-center`
  * `font-bold`
* These utilities allow styling directly in the markup without switching between `.css` and `.tsx` files.
* Tailwind is widely used and frequently appears in job descriptions.

---

## 2. Install Tailwind CSS

### Step 1: Go to the official documentation

Visit `tailwindcss.com` → Documentation → Vite installation.

### Step 2: Install required libraries

Instead of npm, use bun.

In a new terminal:

-------------------code----------------------
cd packages/client
bun add tailwindcss @tailwindcss/vite
-------------------code----------------------

(These are the two libraries required for Tailwind.)

---

## 3. Configure Tailwind with Vite

### Step 1: Open `vite.config.ts`

Import the Tailwind plugin:

-------------------code----------------------
import tailwindcss from "tailwindcss";
-------------------code----------------------

Add it to the plugins list:

-------------------code----------------------
plugins: [
  react(),
  tailwindcss()
]
-------------------code----------------------

---

## 4. Import Tailwind into the Root CSS File

Open `index.css` in the client:

Add:

-------------------code----------------------
@import "tailwindcss";
-------------------code----------------------

That completes the Tailwind configuration.

---

## 5. Start the Application

Return to the root terminal and run:

-------------------code----------------------
bun run dev
-------------------code----------------------

Tailwind is now active.

---

## 6. Apply Basic Styling in React

Open `app.tsx`.

Add a `className` to style the displayed message:

-------------------code----------------------
<p className="font-bold p-4 text-3xl">
  {message}
</p>
-------------------code----------------------

### Explanation of utilities:

* `font-bold` → bold text
* `p-4` → padding of 1rem
* `text-3xl` → large text size

---

## 7. VS Code Extension Recommendation

Install the **Tailwind CSS IntelliSense** extension for:

* Syntax highlighting
* Class name auto-completion
* Improved workflow

Search for **Tailwind CSS IntelliSense** in the Extensions panel.

---

## 8. Wrap Up

After verifying everything works:

* Make a commit with the message:
  **setup tailwind css**

---

*** 10- Setting Up Shadcn ***
---

# Setting Up ShadCN UI Component Library

### Lecture Notes

## 1. Introduction to ShadCN

* ShadCN is a **modern, accessible, and customizable UI component library**.
* Website: [ui.shadcn.com](https://ui.shadcn.com)
* Features:

  * Pre-built, visually appealing components
  * Fully compatible with Tailwind CSS
  * Easy integration with Vite and React

---

## 2. Prerequisites

* Tailwind CSS installed and configured (from previous lesson)
* Vite project created

---

## 3. Update TypeScript Configuration

### Step 1: Modify `tsconfig.json`

* Locate **base TypeScript config** in `client/tsconfig.json`
* Add required `compilerOptions` as suggested in the ShadCN docs

### Step 2: Modify `tsconfig.app.json`

* Locate the file used by React app
* Add or update `baseUrl` and `paths` under `compilerOptions`

### Step 3: Update Node Types

* Install Node types in the client directory:

  -------------------code----------------------
  bun add -d @types/node
  -------------------code----------------------

---

## 4. Update Vite Configuration

### Step 1: Import dependencies

-------------------code----------------------
import path from "path";
import tailwindcss from "tailwindcss";
-------------------code----------------------

### Step 2: Add plugins and resolve property

-------------------code----------------------
plugins: [
  react(),
  tailwindcss()
],
resolve: {
  alias: { /* your aliases */ }
}
-------------------code----------------------

---

## 5. Run ShadCN CLI

### Step 1: Use `bunx` (similar to npx) in the client directory:

-------------------code----------------------
bunx --bun shadcn@latest init
-------------------code----------------------

### Step 2: Choose base color

* Options: `neutral`, `gray`, `zinc`, `stone`, etc.
* Reference the website’s colors page for visual examples
* Example choice: `neutral`

### Step 3: Generated files

* `components.json` → keeps track of installed components (internal use)
* `index.css` → updated with theme variables (colors, padding, etc.)

---

## 6. Install Components

### Step 1: Choose a component

* Example: **Button**

### Step 2: Use ShadCN CLI to install

-------------------code----------------------
bunx --bun shadcn@latest add button
-------------------code----------------------

### Step 3: Verify installation

* Source code appears in the `components` folder
* Tailwind CSS classes used for styling
* Fully customizable

---

## 7. Use Components in React

### Step 1: Update `app.tsx`

* Wrap multiple elements in a root element (e.g., `<div>`)
* Import the component:

-------------------code----------------------
import { Button } from "./components/ui/button";
-------------------code----------------------

* Example usage:

-------------------code----------------------
<div className="p-4">
  <p>{message}</p>
  <Button>Click me</Button>
</div>
-------------------code----------------------

### Step 2: Adjust spacing

* Use padding classes like `p-4` on container to avoid elements touching screen edges

---

## 8. Wrap Up

* Confirm component renders correctly in the browser
* Make a commit with message:
  **set up shadcn ui**

---

*** 11- Formatting Code with Prettier ***
---

# Prettier Setup — Organized Lecture Notes

## 1. Overview

Prettier is a code-formatting tool that automatically handles spacing, indentation, semicolons, and other stylistic rules.
Benefits include consistent formatting, reduced distractions, and cleaner collaboration.

---

## 2. Installing the Prettier Extension

1. Open the **Extensions** panel in VS Code.
2. Search for **Prettier**.
3. Install the extension if it is not already installed.

---

## 3. Creating the Prettier Configuration File

Prettier can be customized by creating a configuration file.

### Steps

1. In the root of the project, create a file named **.prettierrc**.
2. Add a JSON object containing the desired formatting rules.

### Recommended Settings Used in This Lesson

* `"singleQuote": true`

  * Use single quotes in JavaScript/TypeScript files.
  * Note: JSON itself must always use double quotes.
* `"semi": true`

  * Forces semicolons at the end of statements.
* `"trailingComma": "es5"`

  * Adds trailing commas where valid in ES5 (objects, arrays, function arguments).
* `"printWidth": 80`

  * Maximum line length (default).
* `"tabWidth": 3`

  * Indentation width changed from the default of 2 to 3.
-------------------code----------------------
{
   "singleQuote": true,
   "semi": true,
   "trailingComma": "es5",
   "printWidth": 80,
   "tabWidth": 3
}
-------------------code----------------------

---

## 4. Applying Prettier in VS Code

### Format Manually

1. Open a file such as **app.tsx**.
2. Make some unformatted changes (e.g., switch to double quotes, remove semicolons).
3. Open the Command Palette:

   * View → Command Palette
   * Shortcut: **Shift + Command + P** on macOS
4. Search for **Format Document**.
5. When prompted, choose **Prettier** as the default formatter.
6. Prettier will format the file according to the defined rules.

### Format on Save

1. Open **Settings** (Command + Comma on macOS).
2. Search for **Format On Save**.
3. Enable it.
4. Prettier will now automatically format whenever you save a file.

---

## 5. Using Prettier from the Command Line

This is useful before committing code to Git to ensure global consistency.

### Step 1: Install Prettier as a Dev Dependency

In the terminal at the **root of the project**, run:
`bun add -d prettier`

(This ensures Prettier belongs to the overall project, not just server or client.)

### Step 2: Add a Format Script

Open **package.json** and add a script:

-------------------code----------------------
"scripts": {
   "format": "prettier --write ."
}
-------------------code----------------------

The period indicates “run starting from the current directory”.

### Step 3: Create a .prettierignore File

Create a file named **.prettierignore** in the project root.
List files/folders that should not be formatted:

-------------------code----------------------
node_modules
bun.lock
-------------------code----------------------

This prevents formatting of third-party dependencies and lock files.

### Step 4: Run the Formatter

In the terminal:
`bun run format`

This formats all project files except ignored paths.

---

## 6. Summary

You installed Prettier, created a configuration file, set up VS Code integration, and added a command-line workflow with `.prettierrc`, `.prettierignore`, and a `format` script. This completes the setup of Prettier for the project.

---


*** 12- Automating Pre-Commit Checks with Husky ***

---

# Automating Code Formatting with Husky and lint-staged — Organized Lecture Notes

## 1. The Problem

Running Prettier manually before every commit is good practice, but it is easy to forget.
If formatting is skipped, unformatted code may be committed.
Husky solves this by automating tasks such as formatting or testing before commits or pushes.

---

# 2. Installing and Initializing Husky

## Step 1: Install Husky

Run the install command from the Husky documentation in the project root:

-------------------code----------------------
bun add -d husky
-------------------code----------------------

## Step 2: Initialize Husky

This creates a `.husky` directory and a default `pre-commit` script.

-------------------code----------------------
bunx husky init
-------------------code----------------------

After initialization, a `.husky/pre-commit` file appears.
By default, it contains a command to run tests (`bun test`).

Since the project currently has no tests, this command will be replaced.

---

# 3. The Issue with Formatting the Entire Codebase

Running:

-------------------code----------------------
bun run format
-------------------code----------------------

inside the pre-commit script will format the **entire** project.

This causes two problems:

1. **Performance**
   Formatting the whole project becomes slow as the codebase grows.

2. **Misleading commits**
   If only two files were modified, formatting unrelated files brings extra changes into the commit history.
   This affects clarity when reviewing commit logs.

To avoid this, formatting should be applied only to **staged** files.

---

# 4. Using lint-staged to Format Only Staged Files

## Step 1: Install lint-staged

-------------------code----------------------
bun add -d lint-staged
-------------------code----------------------

## Step 2: Update the Husky pre-commit Script

Replace the default command with:

-------------------code----------------------
bunx lint-staged
-------------------code----------------------

(If VS Code fails to run this command, replace `bunx` with `npx`.)

---

# 5. Creating the lint-staged Configuration

In the project root, create a file named:

-------------------code----------------------
.lint-stagedrc
-------------------code----------------------

Inside it, define which tasks apply to which staged files.

### Example configuration:

-------------------code----------------------json
{
   "*.{js,jsx,ts,tsx,css}": "prettier --write"
}
-------------------code----------------------

Notes:

* File patterns are specified in the key.
* Prettier is run **only** on staged files.
* No period (`.`) is used with Prettier here, because that would format the entire codebase.

---

# 6. Demonstrating the Workflow

1. Modify a file (for example `app.tsx`) and intentionally break formatting.
2. Do **not** save the file if autosave is enabled, to avoid Prettier formatting on write.
3. Make a commit.

If VS Code encounters the error:

-------------------code----------------------
bunx: command not found
-------------------code----------------------

this is due to a known issue.
Workarounds:

### Option A: Commit using the terminal

The Husky script runs successfully.

### Option B: Replace `bunx` with `npx`

Update `.husky/pre-commit`:

-------------------code----------------------
npx lint-staged
-------------------code----------------------

This allows using the VS Code Source Control panel normally.

When the commit is made, lint-staged formats the staged files, and `app.tsx` becomes properly formatted.

---

# 7. Removing an Accidental Commit

If a test commit needs to be removed:

1. View history:

-------------------code----------------------
git log --oneline
-------------------code----------------------

2. Move HEAD back one commit:

-------------------code----------------------
git reset --hard HEAD~1
-------------------code----------------------

3. Verify:

-------------------code----------------------
git log --oneline
-------------------code----------------------

The history will now point to the previous commit.

---

# 8. Summary

* Husky automates tasks before commits or pushes.
* lint-staged ensures only staged files are formatted.
* The workflow avoids slow operations and unnecessary formatting commits.
* VS Code's temporary issue with `bunx` can be bypassed by using `npx`.

In the next section, development of the first project will begin.

---

Error:
PS:
This error means **Husky cannot initialize because your project does not have a Git repository yet**.
Husky requires a `.git` folder in your project root.

Here is how to fix it.

---

# How to Solve: `.git can't be found`

## 1. Check if the project is a Git repo

In the root of your project, run:

-------------------code----------------------
ls -a
-------------------code----------------------

If you do **not** see a `.git` directory, then Git is not initialized.

---

## 2. Initialize Git

In the root of your project, run:

-------------------code----------------------
git init
-------------------code----------------------

This will create:

-------------------code----------------------
.git/
-------------------code----------------------

Now Husky can be installed.

---

## 3. Run Husky initialization again

After initializing Git, run:

-------------------code----------------------
bunx husky init
-------------------code----------------------

It should succeed and create:

-------------------code----------------------
.husky/
   pre-commit
-------------------code----------------------

---

# Summary

You must **initialize the project as a Git repository first**.
Once `.git` exists, Husky can be set up without issues.
