*** 1- Introduction ***
---

# Full Stack Project Setup

### Course Foundation Overview

## 1. Introduction

Before building the application, we need to set up a clean, modern full stack project. This project will serve as the foundation for everything covered throughout the course.

## 2. Why Not Use Existing Templates

There are many templates and GitHub starter projects for full stack applications, but this course does not rely on them because:

* We want full control over the setup.
* We avoid depending on someone else’s configuration.
* We do not want to introduce tools that have not yet been explained.

## 3. Why Not Use Next.js

Although Next.js is a powerful full stack framework built on React:

* It has its own learning curve.
* Not everyone likes using it.
* The course should not require Next.js knowledge beforehand.

Instead, the entire setup will be built manually for clarity and flexibility.

## 4. Tools Used in the Setup

The project will be built from scratch using the following technologies:

### Core Tools

* **Bun**: For package management and running the development environment.
* **Vite**: For creating and bundling the frontend.
* **Express**: For building the backend API.

### Additional Tools

* **Tailwind CSS**: For styling the frontend.
* **ShadCN UI**: For reusable UI components.
* **Prettier**: For formatting the codebase.
* **Husky**: For automating workflows, such as pre-commit checks.

## 5. Outcome of This Section

By the end of this part of the course, you will have:

* A fully configured full stack foundation.
* A lightweight and scalable structure.
* A setup that is clean, transparent, and easy to understand.
* A development environment fully customized and owned by you.

## 6. Next Steps

With the tools and structure planned, the next step is to begin the actual setup and configuration of the project.

---

*** 2- Setting Up Bun ***
---

# Introduction to Bun

### A Modern JavaScript Runtime for This Course

## 1. What Is Bun

* Bun is a modern JavaScript runtime similar to Node.js.
* It is designed to be faster and more integrated than the traditional Node.js toolchain.

## 2. Why Use Bun

With Node.js, developers typically rely on several separate tools:

* **npm** for package installation
* **ts-node** for running TypeScript
* **nodemon** for automatically restarting the server

Bun replaces all of these by providing:

* A JavaScript and TypeScript runtime
* A package manager
* A task runner
* A built-in TypeScript transpiler

This means Bun can run TypeScript files directly without requiring additional tools.

## 3. Compatibility with Node.js

* If someone prefers using Node.js, everything taught in the course can still be done with Node.
* However, Bun generally offers a cleaner and more enjoyable development experience.

## 4. Installing Bun

### Steps

1. Go to **bun.sh**.
2. On the homepage, locate the installation command for your operating system.
3. Copy the command and run it in your terminal.
-------------------code----------------------
curl -fsSL https://bun.com/install | bash
-------------------code----------------------
4. Follow the terminal instructions.

   * On macOS, for example, you may need to run:

     -------------------code----------------------
     exec /bin/zsh
     -------------------code----------------------

## 5. Verify Installation

After installation, run:

-------------------code----------------------
bun --version
-------------------code----------------------

Example:

* The instructor is using Bun version **1.2.17**.

## 6. Next Lesson

The next part of the course will cover the project structure.

---


*** 3- Creating the Project Structure ***

---

# Creating the Project Structure

### Setting Up a Full Stack Workspace with Bun

## 1. Create the Main Project Directory

1. Open a terminal window.
2. Navigate to the desired location (for example, the desktop).
3. Create a new directory for the project:

   -------------------code----------------------
   mkdir app
   -------------------code----------------------
4. Move into the directory:

   -------------------code----------------------
   cd app
   -------------------code----------------------

## 2. Initialize the Project with Bun

Run:

-------------------code----------------------
bun init
-------------------code----------------------

### What This Does

* Similar to `npm init`.
* Generates a `package.json` file.
* Creates additional project files.
* Installs TypeScript automatically.

### Template Selection

When prompted to choose a template:

* Options: `blank`, `react`, `library`.
* Choose **blank**.

### Files Created

* `.gitignore`
* A directory for Cursor editor rules (safe to delete if not using Cursor)
* `index.ts` (initial file with a simple console log)
* `tsconfig.json`
* `README.md`
* `node_modules`
* `bun.lockb`

Open the project folder in VS Code.

## 3. Preparing for a Full Stack Architecture

To manage a frontend (client) and backend (server) within a single project, we will use **Bun workspaces**.

### What Are Workspaces

* A built-in feature in Bun (also available in Node with other tools).
* Allows managing multiple sub-projects under one root project.
* Useful for monorepos containing separate client and server apps.

## 4. Creating the Workspace Structure

1. Inside the root project, create a new directory:

   -------------------code----------------------
   packages
   -------------------code----------------------
2. Inside `packages`, create two subdirectories:

   * `client`
   * `server`

Final folder structure:

-------------------code----------------------
app
 ├── packages
 │    ├── client
 │    └── server
 ├── package.json
 ├── tsconfig.json
 ├── index.ts
 ├── node_modules
 └── other config files
-------------------code----------------------

## 5. Declaring Workspaces in package.json

Open `package.json` and add a new property:

-------------------code----------------------json
{
  "workspaces": ["packages/*"]
}
-------------------code----------------------

### Explanation

* `packages/*` is shorthand for including all subfolders inside `packages` as workspaces.
* No need to list each folder individually.

## 6. Initialize Git

To version-control the project:

1. Run:

   -------------------code----------------------
   git init
   -------------------code----------------------
2. Create the first commit:

   -------------------code----------------------
   git add .
   git commit -m "Initial commit"
   -------------------code----------------------

## 7. Next Steps

In upcoming lessons, the client and server subprojects will be created independently inside the workspace structure.

---


*** 4- Creating the Backend ***
---

# Creating the Server Application

### Setting Up the Backend with Bun and Express

## 1. Initialize the Server Subproject

1. In the terminal, navigate to the server directory:

   -------------------code----------------------
   cd packages/server
   -------------------code----------------------
2. Run:

   -------------------code----------------------
   bun init
   -------------------code----------------------
3. Choose the **blank** template.

This creates the same starter files as before.
Remove the unused Cursor directory to keep the project clean.

---

# 2. Install Dependencies

## Install Express

Bun uses `bun add` instead of `npm install`:

-------------------code----------------------
bun add express
-------------------code----------------------

## Install Type Definitions for TypeScript

-------------------code----------------------
bun add -d @types/express
-------------------code----------------------

After installation, the `package.json` inside `packages/server` will contain:

* `express` as a dependency
* `@types/express` as a development dependency

Note:
The workspace uses a single top-level `node_modules` directory.
Client and server do not have separate `node_modules` folders.

---

# 3. Creating the Web Server

Open `packages/server/index.ts`.

## Import Express

-------------------code----------------------
import express from "express";
-------------------code----------------------

## Create the Express Application

-------------------code----------------------
const app = express();
-------------------code----------------------

## Configure the Port

Use an environment variable if available; otherwise default to 3000:

-------------------code----------------------
const port = process.env.PORT || 3000;
-------------------code----------------------

## Define a Route

-------------------code----------------------
app.get("/", (req, res) => {
  res.send("Hello World");
});
-------------------code----------------------

## (Optional) Add Type Annotations

-------------------code----------------------
import type  { Request, Response } from "express";

app.get("/", (req: Request, res: Response) => {
  res.send("Hello World");
});
-------------------code----------------------

## Start the Server

-------------------code----------------------
app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
-------------------code----------------------

---

# 4. Running the Server

In the server directory:

-------------------code----------------------
bun run index.ts
-------------------code----------------------

Click the printed URL (on macOS using Command + click) to open it in the browser.

---

# 5. Adding Custom Scripts

Open **packages/server/package.json**
Add a `scripts` section:

-------------------code----------------------
{
  "scripts": {
    "start": "bun run index.ts",
    "dev": "bun --watch run index.ts"
  }
}
-------------------code----------------------

### Explanation

* `start`: Runs the application normally.
* `dev`: Runs the server in watch mode so it restarts automatically on file changes.

---

# 6. Running Scripts

## Start the Server

-------------------code----------------------
bun start
-------------------code----------------------

## Run in Watch Mode

Because `dev` is a custom script:

-------------------code----------------------
bun run dev
-------------------code----------------------

Changing the server code (for example removing an exclamation mark in the response) will automatically restart the server, and refreshing the browser will show the updated output.

---


*** 5- Managing OpenAI API Key ***
---

# Managing API Keys and Environment Variables

## 1. Why API Keys Should Not Be Stored in Source Code

* Never hardcode sensitive values such as API keys in files like `index.ts`.
* Anyone with access to the source code could use the key and cause unwanted usage charges.
* The correct approach is to use environment variables.

---

# Setting Environment Variables Manually

## 2. Setting a Temporary Environment Variable in the Terminal

* Stop the running server.
* On macOS/Linux:

  -------------------code----------------------
  export OPENAI_API_KEY=1234
  -------------------code----------------------
* On Windows:

  -------------------code----------------------
  set OPENAI_API_KEY=1234
  -------------------code----------------------
* Environment variables are conventionally written in uppercase.

## 3. Reading Environment Variables in Code

In `index.ts`, use:

-------------------code----------------------
process.env.OPENAI_API_KEY
-------------------code----------------------

* Temporarily return this value in a route handler to verify it is received correctly.

## 4. Restart and Test

* Start the server again.
* Refresh the browser.
* The value is read successfully.

---

# The Problem with Manual Environment Variables

* Each time you start the application, you would have to manually set the variables.
* This is repetitive and error-prone.

---

# Using the `dotenv` Library

## 5. Install dotenv

In the server project directory:

-------------------code----------------------
bun add dotenv
-------------------code----------------------

## 6. Create a `.env` File

Inside `packages/server`:

-------------------code----------------------
.env
-------------------code----------------------

* `.env` files are ignored by Git automatically (verified in `.gitignore`).
* Declare variables inside:

-------------------code----------------------
OPENAI_API_KEY=ABCD
-------------------code----------------------

## 7. Load `.env` Variables in Code

At the top of `index.ts`:

-------------------code----------------------
import dotenv from "dotenv";
dotenv.config();
-------------------code----------------------

* This must be the first line in the file.
* It loads all key-value pairs from `.env` into `process.env`.

## 8. Restart the Application

* Restart the server.
* You will see a message:
  `dotenv is injecting environment variables`
* However, if you previously set the variable in the terminal, the terminal version overrides `.env`.

---

# Removing Old Environment Variables

## 9. Remove the Terminal Variable

On macOS/Linux:

-------------------code----------------------
unset OPENAI_API_KEY
-------------------code----------------------

On Windows:

-------------------code----------------------
set OPENAI_API_KEY=
-------------------code----------------------

* Restart the server again.
* Now the value from `.env` appears correctly.

---

# Using a Real API Key

## 10. Replace the Placeholder Value

In `.env`:

-------------------code----------------------
OPENAI_API_KEY=your_real_api_key_here
-------------------code----------------------

---

# Providing a Template for Others

## 11. Create `.env.example`

Duplicate `.env` and name it:

-------------------code----------------------
.env.example
-------------------code----------------------

* This file is included in the repository.
* It lists variable names without actual values:

-------------------code----------------------
OPENAI_API_KEY=
-------------------code----------------------

* This helps other developers understand what they must configure.

---

# Final Cleanup

## 12. Restore Main Route Output

Replace temporary code with the original response:

-------------------code----------------------
res.send("Hello World");
-------------------code----------------------

## 13. Commit the Changes

Commit message example:

-------------------code----------------------
manage openai api key
-------------------code----------------------

---

# Important Note

* If you change anything inside the `.env` file, Bun will not reload it automatically.
* You must manually restart the application each time you update `.env`.

---


*** 6- Creating the Frontend ***
---

# Setting Up the Front-End Application with Vite

## 1. Introduction to Vite

* Vite is a fast, modern build tool for front-end applications.
* Commonly used for React, Vue, and other frameworks.
* Documentation: vite.dev

---

# Creating the Front-End Project

## 2. Navigate to the Vite Documentation

* On vite.dev, go to "Get Started".
* The official command for creating a project with npm is:

  -------------------code----------------------
  npm create vite@latest
  -------------------code----------------------
* Vite also supports Bun.

---

## 3. Prepare the Workspace in VS Code

* Open a new terminal window.
* For better organization, use two terminals:

  * One for the **server**
  * One for the **client**
* Rename terminal tabs accordingly:

  * Server terminal → rename to `server`
  * Client terminal → rename to `client`
* Optional: color-code them for clarity (example: server green, client yellow).

---

# Creating the Client Project

## 4. Navigate to the Correct Directory

-------------------code----------------------
cd packages/client
-------------------code----------------------

## 5. Run the Vite Creation Command

* Paste the Vite command:

  -------------------code----------------------
  bun create vite
  -------------------code----------------------
* Do **not** run it immediately.
* If executed directly, Vite will create a **subdirectory**, which is not desired.
* Instead, append a period (`.`) to create the project **in the current directory**:

  -------------------code----------------------
  bun create vite .
  -------------------code----------------------

## 6. Choose the Project Options

* **Framework:** React
* **Variant:** TypeScript

---

# Project Structure

## 7. Resulting Directory

Inside `packages/client`, Vite generates a standard React project structure.
You will now have:

* A `package.json` for the client
* A `package.json` for the server
* A root `package.json`

Total: **three** `package.json` files.

---

# Installing Dependencies

## 8. Install Dependencies with Bun

In the root of the project (workspace root):

-------------------code----------------------
bun install
-------------------code----------------------

* This installs all dependencies into **one shared top-level `node_modules`** directory.
* You will **not** have separate `node_modules` folders for client and server.

---

# Running the Client Application

## 9. Start the Development Server

Inside the client terminal:

-------------------code----------------------
bun run dev
-------------------code----------------------

* The `dev` script comes from `packages/client/package.json`.

Example scripts section:

-------------------code----------------------json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint ."
  }
}
-------------------code----------------------

## 10. Verify the Application

* Open the displayed local development URL in the browser.
* You should see the default React + Vite project running successfully.

---

# Final Step

## 11. Make a Git Commit

Commit message example:

-------------------code----------------------
create frontend
-------------------code----------------------

This marks the completion of setting up the client-side project.

---

*** 7- Connecting the Frontend and Backend ***
---

# Connecting the Client and Server Applications

### Lecture Notes

## 1. Creating a New Endpoint in the Server Application

1. Open the server application and navigate to `index.ts` in the server directory.
2. Duplicate an existing route handler using the shortcut:

   * macOS: **Option + Shift + Down Arrow**
   * Windows: **Shift + Alt + Down Arrow**
3. Modify the duplicated route:

   * Change the path to `/api/hello`.
   * Return a JSON object instead of plain text:

-------------------code----------------------
app.get("/api/hello", (req: Request, res: Response) => {
  res.json({ message: "Hello World!" });
});
-------------------code----------------------

4. Test the new endpoint in the browser by visiting `/api/hello`.
5. If the JSON is not formatted, install the "JSON Formatter" browser extension.

---

## 2. Preparing the Client Application (React)

### Cleaning Up `app.tsx`

1. Open `app.tsx`.
2. Remove all import statements and all existing code inside the component.
3. Use the selection expansion shortcut:

   * macOS: **Control + Shift + Command + Right Arrow**
   * Right Arrow expands selection, Left Arrow shrinks it.
4. Select the needed block and delete it.

---

## 3. Adding State and Effect Hooks

### Declare State

-------------------code----------------------
const [message, setMessage] = useState("");
-------------------code----------------------

### Make an API Call with `useEffect`

1. Use the `fetch` API to call `/api/hello`.
2. Convert the response to JSON.
3. Set `message` to `data.message`.
4. Provide an empty dependency array so the effect runs once.

### Render Output

Return a simple paragraph that displays the message:

-------------------code----------------------
<p>{message}</p>
-------------------code----------------------

---

## 4. Why the Request Fails Initially

If you call `/api/hello` from the client, it fails because that endpoint only exists on the server.
The client development server needs to forward API requests to the backend.

---

## 5. Setting Up a Proxy in Vite

1. Open `vite.config.ts`.
2. Add a `server` property with a `proxy` configuration:

   -------------------code----------------------
   server: {
     proxy: {
       "/api": "http://localhost:3000"
     }
   }
   -------------------code----------------------


3. This ensures:

   * Requests to `/api/...` from the client automatically forward to
     `http://localhost:3000/api/...`.

4. restart the server and client
---

## 6. Testing the Integrated Application

1. Refresh the client application in the browser.
2. The "hello world" message should appear.
3. It may be centered due to default styles.

---

## 7. Fixing Client Styling

1. Open `index.css` in the client.
2. Remove all default styles.
3. Refresh the browser and confirm the layout looks correct.

---

## 8. Final Step: Commit the Changes

Use a clear commit message, such as:
**"Connect the front end and back end."**

---

*** 8- Running Both Apps Together ***
---

# Running Server and Client with a Single Command

### Lecture Notes

## 1. Problem: Two Terminals Needed

In the current setup, starting the application requires:

* One terminal to run the server: `bun run dev`
* Another terminal to run the client: `bun run dev`

This becomes repetitive and inefficient.

---

## 2. Goal

Start **both** the server and client applications simultaneously using **one command**.

---

## 3. Install Concurrently

1. Stop both the client and server.
2. Open a new terminal at the **root** of the project.
3. Install the dependency:

   -------------------code----------------------
   bun add -d concurrently
   -------------------code----------------------

`concurrently` lets you run multiple commands in parallel.

---

## 4. Create a Root-Level `index.ts`

Inside the **root directory**, open or create `index.ts`.

### Remove old console logs

Delete any existing console log statements.

### Import and use concurrently

-------------------code----------------------
import concurrently from "concurrently";

concurrently([
  {
    name: "server",
    command: "bun run dev",
    cwd: "packages/server",
    prefixColor: "cyan"
  },
  {
    name: "client",
    command: "bun run dev",
    cwd: "packages/client",
    prefixColor: "green"
  }
]);
-------------------code----------------------

### Explanation of properties

* **name**: identifies the process in the terminal.
* **command**: the command used to start the app.
* **cwd**: directory from which the command should run.
* **prefixColor** (optional): assigns a color so messages are easier to read in a single terminal window.

---

## 5. Add a Custom Script in Root `package.json`

Open the **package.json** in the root directory and create a new script:

-------------------code----------------------
{
  "scripts": {
    "dev": "bun run index.ts"
  }
}
-------------------code----------------------

This allows running both apps with a single command.

---

## 6. Run Both Applications

In the **root directory**, run:

-------------------code----------------------
bun run dev
-------------------code----------------------

Both apps will start at once:

* Server logs appear in cyan
* Client logs appear in green

---

## 7. Test the Setup

1. Open the browser.
2. Refresh the client application.
3. Confirm that everything loads correctly.

---

## 8. Wrap Up

Since both applications now start through one root command:

* Individual server/client terminals are no longer needed.
* You can make a commit with a message like:
  **run both apps together**

---
